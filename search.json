[{"title":"Git的一些基本操作","url":"/2021/04/19/Git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","content":"1、Git介绍\n Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本       管理。\n Git 是 Linus Torvalds 为了帮助管理 Linux内核开发而开发的一个开放源码的版本控制软件。\n 大概知道它是个开源的分布式版本控制系统就行了，我们主要学习Git的使用。\n Git官网(https://git-scm.com/)\n\n2、初始化仓库git init\n\n3、设置签名(级别优先级，就近原则     仓库 &gt; 系统 )仓库签名:    git config user.name code    git config user.emali code@code.com    系统用户级别签名:    git config --global user.name code    git config --global user.emali code@code.com\n4、状态查看git status\n5、添加文件git add 文件名\n6、提交git commit -m &quot;提交描述&quot; 提交的文件名\n7、查看历史记录git loggit log --pretty&#x3D;oneline  &#x2F;&#x2F;查看一行记录git log --oneline  &#x2F;&#x2F;查看一行记录git reflog\n8、前进后退（回退版本就能找回上个版本的内容）git reset --hard [局部索引值]&#x2F;&#x2F;使用^、~符号，只能后退git reset --hard HEAD^ &#x2F;&#x2F;一个^后退一步n个后退n步git reset --hard HEAD~n &#x2F;&#x2F;后退n步\n9、比较文件差异git diff 文件名（不带文件名比较多个文件）\n10、分支\t&#x2F;&#x2F;创建分支\tgit branch [分支名]&#x2F;&#x2F;查看分支git branch -v&#x2F;&#x2F;切换分支git checkout [分支名]&#x2F;&#x2F;合并分支   git checkout [被合并分支名]  &#x2F;&#x2F;切换到接受修改的分支（被合并，增加新内容 ) 上   git merge [有新内容分支名]  &#x2F;&#x2F;执行 merge 命令,合并分支\n11、解决冲突     第一步：编辑文件，删除特殊符号第二步：把文件修改到满意的程度，保存退出第三步：git add [文件名]第四步：git commit -m &quot;日志信息&quot;   &#x2F;&#x2F;注意：此时 commit 一定不能带具体文件\n12、创建远程库地址别名git remote -v 查看当前所有远程地址别名git remote add [别名] [远程地址]\n13、推送git push [别名] [分支名]\n14、克隆git clone [远程地址]\n15、拉取git fetch [远程库地址别名] [远程分支名]git merge [远程库地址别名&#x2F;远程分支名]git pull [远程库地址别名]  &#x2F;&#x2F;pull&#x3D;fetch+merge\n16、SSH 登录(免密登陆)进入当前用户的家目录：cd ~ 删除.ssh 目录(没有或者以前生成过可以忽略这步)： rm -rvf .ssh运行命令生成.ssh 密钥目录  [注意：这里-C 这个参数是大写的 C]：  \t\tssh-keygen -t rsa -C code@qq.com &#x2F;&#x2F;邮箱改成自己的\t\t进入.ssh 目录查看文件列表:  cd .ssh | ls -lF  (可以忽略)查看 id_rsa.pub 文件内容 :    cat id_rsa.pub （可以忽略）复制 id_rsa.pub 文件内容，登录 GitHub点击用户头像→Settings→SSH and GPG\tkeys &#x3D;&gt; New SSH Key   \t输入复制的密钥信息回到 Git bash 创建远程地址别名git remote add origin_ssh [ssh链接]推送文件进行测试   \n\n\n\n\n​    \n"},{"title":"JDK11以及更高版本JDK使用JavaFX","url":"/2021/05/22/JDK11%E4%BB%A5%E5%8F%8A%E6%9B%B4%E9%AB%98%E7%89%88%E6%9C%ACJDK%E4%BD%BF%E7%94%A8JavaFX/","content":"JDK11以及更高版本JDK使用JavaFX从JDK11开始，JavaFX就从jdk中分出来了。如果要使用javafx，就需要配置一下。\n首先下载[JavaFX的依赖][1]，解压得到下面文件\n\n以eclipse创建javaFX工程举例\n\n新建一个普通工程\n\n\n引入javaFX依赖，如图操作\n\n\n\n\n\n\n\n然后点击Finish  =&gt; Apply and Close\n\n有自己导入的依赖就可以了\n测试一下\n\n新建一个包、包下放2个类(App.java    Test.java)\nApp.java\nimport javafx.application.Application;import javafx.stage.Stage;public class App extends Application&#123;\t@Override\tpublic void start(Stage prStage) throws Exception\t&#123;\t\tprStage.setTitle(&quot;Hello World&quot;);\t\tprStage.show();\t&#125;&#125;\n\nTest.java\nimport javafx.application.Application;public class Test&#123;\tpublic static void main(String[] args)\t&#123;\t\tApplication.launch(App.class,args);\t&#125;&#125;\n\n\n\n可能你会问    为什么不直接像下面这样写？\nimport javafx.application.Application;import javafx.stage.Stage;public class Test1 extends Application&#123;\t\tpublic static void main(String[] args)\t&#123;\t\tlaunch(args);\t&#125;\t\t@Override\tpublic void start(Stage arg0) throws Exception\t&#123;\t\targ0.show();\t&#125;&#125;\n\n为什么呢？\n因为会报错\n错误: 缺少 JavaFX 运行时组件, 需要使用该组件来运行此应用程序\n\n配置jvm启动参数似乎可以解决，但是这里采用这种引用的方法，更加方便。\n\n\n[1][JavaFX下载 | JavaFX中文官方网站 (openjfx.cn)]\n"},{"title":"JavaFX学习之DialogPane和ScheduledService的简单使用","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8BDialogPane%E5%92%8CScheduledService%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"JavaFX的第十一次接触\n DialogPane对话框\n ScheduledService多任务\n\nimport javafx.application.Application;import javafx.concurrent.ScheduledService;import javafx.concurrent.Task;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.control.ButtonType;import javafx.scene.control.DialogPane;import javafx.scene.image.ImageView;import javafx.scene.layout.AnchorPane;import javafx.scene.text.Text;import javafx.stage.Modality;import javafx.stage.Stage;import javafx.stage.StageStyle;import javafx.util.Duration;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button button = new Button(&quot;点我一下&quot;);        AnchorPane ap = new AnchorPane();        ap.setStyle(&quot;-fx-background-color: #567;&quot;);        ap.getChildren().addAll(button);        AnchorPane.setTopAnchor(button, 100.0);        AnchorPane.setLeftAnchor(button, 100.0);//        按钮点击事件        button.setOnAction(e -&gt; &#123;            DialogPane dialogPane = new DialogPane();            dialogPane.setHeaderText(&quot;HeaderText&quot;);            dialogPane.setContentText(&quot;ContentText&quot;);            dialogPane.getButtonTypes().add(ButtonType.APPLY);//添加应用按钮            dialogPane.getButtonTypes().add(ButtonType.CLOSE);//添加关闭按钮            Button apply = (Button) dialogPane.lookupButton(ButtonType.APPLY);//获取应用按钮            Button close = (Button) dialogPane.lookupButton(ButtonType.CLOSE);//获取关闭按钮//            监听按钮点击事件            apply.setOnAction(ev -&gt; System.out.println(&quot;应用按钮点击了&quot;));            close.setOnAction(ev1 -&gt; System.out.println(&quot;关闭按钮点击了&quot;));            ImageView imageView = new ImageView(&quot;icon/fz.png&quot;);            dialogPane.setGraphic(imageView);//设置右上角图片            dialogPane.setExpandableContent(new Text(&quot;这里有隐藏内容&quot;));//默认隐藏的内容//            dialogPane.setExpanded(true);//改变隐藏内容的默认设置为显示            Scene scene = new Scene(dialogPane);            Stage stage = new Stage();            stage.setScene(scene);//            设置窗口为模态窗口            stage.initOwner(primaryStage);            stage.initStyle(StageStyle.UTILITY);            stage.initModality(Modality.WINDOW_MODAL);            stage.setResizable(false);//禁止窗口拉伸            stage.show();//            多线程操作            MyScheduledService my = new MyScheduledService(dialogPane,stage);//            my.setDelay(Duration.millis(1000));//设置延时            my.setPeriod(Duration.millis(1000));//设置时间间隔            my.start();        &#125;);        Scene scene = new Scene(ap);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;//多任务的简单使用class MyScheduledService extends ScheduledService&lt;Integer&gt; &#123;    private DialogPane dialogPane;    private Stage stage;    int i = 0;    public MyScheduledService(DialogPane dialogPane, Stage stage) &#123;        this.dialogPane = dialogPane;        this.stage = stage;    &#125;    @Override    protected Task&lt;Integer&gt; createTask() &#123;        return new Task&lt;Integer&gt;() &#123;            @Override            protected Integer call() throws Exception &#123;                System.out.println(&quot;call =&gt; &quot; + Thread.currentThread().getName());                return i++;            &#125;            //            更新UI组件要在 updateVale 方法中            @Override            protected void updateValue(Integer value) &#123;                System.out.println(&quot;updateValue =&gt; &quot; + Thread.currentThread().getName());                System.out.println(&quot;updateValue里的value =&gt; &quot; + value);                if (value &lt; 11)&#123;                    dialogPane.setContentText(&quot;当前i的值为 =&gt; &quot; + value);                &#125;else &#123;//                    System.out.println(this);                    MyScheduledService.this.cancel();//关闭线程,不能直接用this,直接用this关不掉                    stage.close();//关闭窗口                &#125;            &#125;        &#125;;    &#125;&#125;\n\n"},{"title":"JavaFX学习之HelloWorld","url":"/2021/05/21/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8BHelloWorld/","content":"JavaFXJavaFX就是Java在编写图形界面程序的最新技术。\nJavaFX的第一次体验\n Hello World\n 建议使用Jdk1.8~10之间的版本，方便开发，不用自己导依赖，配置启动参数，我这里用的是Jdk1.8\n\nimport javafx.application.Application;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        primaryStage.setTitle(&quot;Hello World&quot;);//设置窗口标题        primaryStage.show();//显示窗口    &#125;&#125;\n\n\n\n\n JavaFX的生命周期的简单介绍\n\nimport javafx.application.Application;import javafx.stage.Stage;public class Main1 extends Application &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;main() =&gt; &quot; + Thread.currentThread().getName());//main线程        launch(args);    &#125;    @Override    public void init() throws Exception &#123;        System.out.println(&quot;init() =&gt; &quot; + Thread.currentThread().getName());//初始化 JavaFX-Launcher线程    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        System.out.println(&quot;start() =&gt; &quot; + Thread.currentThread().getName());//运行中 JavaFX Application Thread线程        primaryStage.show();    &#125;    @Override    public void stop() throws Exception &#123;        System.out.println(&quot;stop() =&gt; &quot; + Thread.currentThread().getName());//销毁 JavaFX Application Thread线程    &#125;&#125;\n\n"},{"title":"JavaFX学习之group的简单使用","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8Bgroup%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"JavaFX的第五次接触\n group布局的简单使用\n button按钮的简单使用(位置、宽高)\n group监听节点改变事件\n button点击事件监听\n\nimport javafx.application.Application;import javafx.collections.ListChangeListener;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.Group;import javafx.scene.Node;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;b1&quot;);        Button b2 = new Button(&quot;b2&quot;);        Button b3 = new Button(&quot;b3&quot;);//        自定义按钮位置        b1.setLayoutX(0);        b1.setLayoutY(0);//        自定义按钮宽高        b1.setPrefWidth(50);        b1.setPrefHeight(50);        b2.setLayoutX(50);        b2.setLayoutY(50);//        自定义按钮宽高        b2.setPrefWidth(100);        b2.setPrefHeight(100);        b3.setLayoutX(100);        b3.setLayoutY(100);//        自定义按钮宽高        b3.setPrefWidth(150);        b3.setPrefHeight(150);        Group group = new Group();//        group.getChildren().add(b1);//        group.getChildren().add(b2);//        group.getChildren().add(b3);        group.getChildren().addAll(b1, b2, b3);//效果跟上面一样        System.out.println(&quot;判断坐标位置是否有节点(按钮): &quot; + group.contains(50,50));//节点左上角的坐标        Object[] array = group.getChildren().toArray();//把Group上的所有节点存到数组//        遍历数组,统一设置宽高,会覆盖掉上面设置的宽高        for (Object o : array) &#123;            Button button = (Button) o;            button.setPrefWidth(50);            button.setPrefHeight(50);        &#125;//        group.setOpacity(0.5);//设置透明度(按钮都透明了)//        group.getChildren().remove(b1);//移除b1按钮//        group.getChildren().clear();//移除所有//        group.setAutoSizeChildren(true);//自动设置节点宽高//        b1按钮点击事件        b1.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;            @Override            public void handle(ActionEvent event) &#123;                Button button = new Button(&quot;b4&quot;);                group.getChildren().add(button);            &#125;        &#125;);//        group监听器,监听节点改变        group.getChildren().addListener(new ListChangeListener&lt;Node&gt;() &#123;            @Override            public void onChanged(Change&lt;? extends Node&gt; c) &#123;                System.out.println(&quot;当前组件数量: &quot; + c.getList().size());            &#125;        &#125;);        Scene scene = new Scene(group);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(500);        primaryStage.show();    &#125;&#125;\n\n"},{"title":"JavaFX学习之布局一","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%83%E5%B1%80%E4%B8%80/","content":"JavaFX的第九次接触\n AnchorPane布局\n HBox和VBox布局\n BorderPane布局\n FlowPane布局\n GridPane布局\n\nAnchorPane    定位布局\nimport javafx.application.Application;import javafx.beans.value.ChangeListener;import javafx.beans.value.ObservableValue;import javafx.geometry.Insets;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.AnchorPane;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;b1&quot;);//        定位布局        AnchorPane ap1 = new AnchorPane();        AnchorPane ap2 = new AnchorPane();//默认是没有宽和高的,可以自定义宽高,这里通过父组件设置        ap1.setStyle(&quot;-fx-background-color: #567;&quot;);        ap2.setStyle(&quot;-fx-background-color: #2ecc71;&quot;);//        直接设置b1的位置和坐标是没用的,需要通过b1的父组件ap1来控制//        ap1.setPadding(new Insets(10));//设置padding 10,下面的参数设置了才能看出来//        AnchorPane.setTopAnchor(b1,10.0);//        AnchorPane.setLeftAnchor(b1,10.0);//        AnchorPane.setBottomAnchor(b1,10.0);//        AnchorPane.setRightAnchor(b1,10.0);        ap1.getChildren().addAll(ap2);        ap2.getChildren().add(b1);//        设置b1按钮相对于其父控件ap2的位置        AnchorPane.setRightAnchor(b1,0.0);        AnchorPane.setBottomAnchor(b1,0.0);//        b1.setManaged(false);//设置b1脱离父控件,相当于消失了        b1.setVisible(false);//设置b1是否可见,false为不可见,布局上还有b1但是看不见        b1.setOpacity(0.5);//透明度        Scene scene = new Scene(ap1);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();//        设置ap2的位置、大小        AnchorPane.setTopAnchor(ap2, 0.0);        AnchorPane.setLeftAnchor(ap2, 0.0);        AnchorPane.setRightAnchor(ap2,ap1.getWidth() / 2);        AnchorPane.setBottomAnchor(ap2,ap1.getHeight() / 2);//        动态改变ap2的宽高,要在窗口show方法后面监听,不然获取不到//        lambda写法        primaryStage.widthProperty().addListener((o, oldV, newV) -&gt; &#123;            AnchorPane.setRightAnchor(ap2,ap1.getWidth() / 2);        &#125;);//        普通写法        primaryStage.heightProperty().addListener(new ChangeListener&lt;Number&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) &#123;                AnchorPane.setBottomAnchor(ap2,ap1.getHeight() / 2);            &#125;        &#125;);    &#125;&#125;\n\n\n\nHBox和VBox布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.AnchorPane;import javafx.scene.layout.HBox;import javafx.scene.layout.VBox;import javafx.stage.Stage;public class Main1 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;b1&quot;);        Button b2 = new Button(&quot;b2&quot;);        Button b3 = new Button(&quot;b3&quot;);        AnchorPane ap = new AnchorPane();        ap.setStyle(&quot;-fx-background-color: #567;&quot;);//        HBox box = new HBox();//水平排列,超出局范围也不会换行        VBox box = new VBox();//垂直排列,超出布局范围也不会换行        box.setPrefWidth(500);        box.setPrefHeight(300);        box.setPadding(new Insets(10));//设置padding        box.setSpacing(10);//设置全部子组件外边距        VBox.setMargin(b1,new Insets(10));//单独设置子组件的margin        box.setAlignment(Pos.CENTER);//设置全部子组件的对齐方式        box.setStyle(&quot;-fx-background-color: #123;&quot;);        box.getChildren().addAll(b1,b2,b3);        ap.getChildren().add(box);        Scene scene = new Scene(ap);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;\n\nBorderPane    方位布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.scene.Node;import javafx.scene.Scene;import javafx.scene.layout.AnchorPane;import javafx.scene.layout.BorderPane;import javafx.stage.Stage;public class Main2 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    public void start(Stage stage) &#123;//        5个区域,如果不设置宽和高默认会让中间的区域占满        AnchorPane ap1 = new AnchorPane();        ap1.setStyle(&quot;-fx-background-color: #567;&quot;);        ap1.setPrefHeight(100);        ap1.setPrefWidth(100);        AnchorPane ap2 = new AnchorPane();        ap2.setStyle(&quot;-fx-background-color: #1abc9c;&quot;);        ap2.setPrefHeight(100);        ap2.setPrefWidth(100);        AnchorPane ap3 = new AnchorPane();        ap3.setStyle(&quot;-fx-background-color: #3498db;&quot;);        ap3.setPrefHeight(100);        ap3.setPrefWidth(100);        AnchorPane ap4 = new AnchorPane();        ap4.setStyle(&quot;-fx-background-color: #8e44ad;&quot;);        ap4.setPrefHeight(100);        ap4.setPrefWidth(100);        AnchorPane ap5 = new AnchorPane();        ap5.setStyle(&quot;-fx-background-color: #c0392b;&quot;);        ap5.setPrefHeight(100);        ap5.setPrefWidth(100);//        方位布局        BorderPane bp = new BorderPane();        bp.setStyle(&quot;-fx-background-color: yellow;&quot;);//        设置各个布局的位置        bp.setTop(ap1);        bp.setRight(ap2);        bp.setBottom(ap3);        bp.setLeft(ap4);        bp.setCenter(ap5);        bp.setPadding(new Insets(10));//设置补白        BorderPane.setMargin(ap1,new Insets(10));//设置某个布局的外边距        AnchorPane top = (AnchorPane) bp.getTop();//获取某个方位上的节点        System.out.println(top);        Scene scene = new Scene(bp);        stage.setScene(scene);        stage.setTitle(&quot;javafx&quot;);        stage.setWidth(600);        stage.setHeight(600);        stage.show();    &#125;&#125;\n\nFlowPane    流式布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Orientation;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.FlowPane;import javafx.stage.Stage;public class Main3 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    public void start(Stage s) &#123;        Button b1 = new Button(&quot;b1&quot;);        Button b2 = new Button(&quot;b2&quot;);        Button b3 = new Button(&quot;b3&quot;);        Button b4 = new Button(&quot;b4&quot;);        Button b5 = new Button(&quot;b5&quot;);        Button b6 = new Button(&quot;b6&quot;);//        流式布局,会自动换行        FlowPane fp = new FlowPane();        fp.setStyle(&quot;-fx-background-color: #567;&quot;);        fp.setPadding(new Insets(10));//设置补白//        FlowPane.setMargin(b1,new Insets(10));//设置某个组件的外边距        fp.setAlignment(Pos.CENTER);//设置子组件对齐方式        fp.setHgap(10);//子组件水平间距        fp.setVgap(10);//子组件垂直间距        fp.setOrientation(Orientation.VERTICAL);//设置子组件默认是水平还是垂直排列        fp.getChildren().addAll(b1,b2,b3,b4,b5,b6);        Scene scene = new Scene(fp);        s.setScene(scene);        s.setTitle(&quot;javafx&quot;);        s.setWidth(800);        s.setHeight(600);        s.show();    &#125;&#125;\n\n GridPane    网格布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.ColumnConstraints;import javafx.scene.layout.GridPane;import javafx.scene.layout.RowConstraints;import javafx.stage.Stage;public class Main4 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    public void start(Stage s)&#123;        Button b1 = new Button(&quot;button1&quot;);        Button b2 = new Button(&quot;button2&quot;);        Button b3 = new Button(&quot;button3&quot;);        Button b4 = new Button(&quot;button4&quot;);        Button b5 = new Button(&quot;button5&quot;);        Button b6 = new Button(&quot;button6&quot;);//        网格布局        GridPane gp = new GridPane();        gp.setStyle(&quot;-fx-background-color: #567;&quot;);//        第一种添加节点的方法,设置组件在GridPane布局的第几列,第几行//        gp.add(b1,0,0);        gp.add(b2,1,0);        gp.add(b3,2,0);        gp.add(b4,3,0);        gp.add(b5,0,1);        gp.add(b6,1,1);//        水平跟垂直间距        gp.setHgap(10);        gp.setVgap(10);//        padding        gp.setPadding(new Insets(10));        GridPane.setMargin(b1,new Insets(10));//设置某个子组件的margin        gp.setAlignment(Pos.CENTER);//子组件对齐方式//        第二种添加节点的方法//        GridPane.setConstraints(b1,2,1);//        gp.getChildren().add(b1);//        第三种添加节点的方法        GridPane.setRowIndex(b1,1);//行        GridPane.setColumnIndex(b1,2);//列        gp.getChildren().add(b1);//        设置第一列间距        gp.getColumnConstraints().add(new ColumnConstraints(100));//        设置第一行间距        gp.getRowConstraints().add(new RowConstraints(100));        Scene scene = new Scene(gp);        s.setScene(scene);        s.setTitle(&quot;javafx&quot;);        s.setWidth(800);        s.setHeight(600);        s.show();    &#125;&#125;\n\n"},{"title":"JavaFX学习之按钮样式设置","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8C%89%E9%92%AE%E6%A0%B7%E5%BC%8F%E8%AE%BE%E7%BD%AE/","content":"JavaFX的第六次接触\n 设置按钮的样式\n java代码设置\n css风格设置\n\njava代码设置\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.*;import javafx.scene.paint.Paint;import javafx.scene.text.Font;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button();        b1.setText(&quot;按钮1&quot;);        b1.setLayoutX(50);        b1.setLayoutY(100);        b1.setPrefWidth(100);        b1.setPrefHeight(100);        b1.setFont(Font.font(&quot;sans-serif&quot;,20));//设置字体风格        b1.setTextFill(Paint.valueOf(&quot;#fff&quot;));//设置字体颜色//        BackgroundFill(颜色,圆角，边距(与边框的距离相当于padding,默认可以设置为: Insets.EMPTY))        BackgroundFill bgf = new BackgroundFill(Paint.valueOf(&quot;#456&quot;), new CornerRadii(20), new Insets(10));//        设置背景        Background bg= new Background(bgf);        b1.setBackground(bg);//        设置边框//        BorderStroke(颜色,线框风格,圆角,线框宽度)        BorderStroke stroke = new BorderStroke(Paint.valueOf(&quot;#16a085&quot;), BorderStrokeStyle.DASHED, new CornerRadii(20), new BorderWidths(5));        Border border = new Border(stroke);        b1.setBorder(border);        Group group = new Group();        group.getChildren().add(b1);        Scene scene = new Scene(group);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(500);        primaryStage.show();    &#125;&#125;\n\n\n\ncss风格设置\nimport javafx.application.Application;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.stage.Stage;public class Main1 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button();        b1.setText(&quot;按钮1&quot;);        b1.setLayoutX(50);        b1.setLayoutY(100);        b1.setPrefWidth(100);        b1.setPrefHeight(100);//        css样式写法        b1.setStyle(&quot;-fx-background-color: #456;&quot; +                    &quot;-fx-background-radius: 50;&quot; +                    &quot;-fx-text-fill: #fff;&quot; +                    &quot;-fx-font-size: 20;&quot;                   );//        按钮单击事件        b1.setOnAction(e -&gt; &#123;            Button button = (Button) e.getSource();            System.out.println(&quot;当前按钮文本: &quot; + button.getText());        &#125;);        Group root = new Group();        root.getChildren().add(b1);        Scene scene = new Scene(root);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(500);        primaryStage.show();    &#125;&#125;\n\n"},{"title":"JavaFX学习之布局二","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%B8%83%E5%B1%80%E4%BA%8C/","content":"JavaFX的第十次接触\n StackPane布局\n TextFlow布局\n TilePane布局\n\nStackPane布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.StackPane;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;button1&quot;);        Button b2 = new Button(&quot;button2&quot;);        Button b3 = new Button(&quot;button3&quot;);        Button b4 = new Button(&quot;button4&quot;);        Button b5 = new Button(&quot;button5&quot;);        Button b6 = new Button(&quot;button6&quot;);        StackPane sp = new StackPane();        sp.setStyle(&quot;-fx-background-color: #567;&quot;);        sp.setPadding(new Insets(10));//设置补白        sp.setAlignment(Pos.BOTTOM_LEFT);//子组件定位//        设置某个子组件的margin        StackPane.setMargin(b2,new Insets(100));        sp.getChildren().addAll(b1,b2,b3,b4,b5,b6);//        获取布局上的所有子组件        sp.getChildren().forEach(System.out::println);        Scene scene = new Scene(sp);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;\n\nTextFlow布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.scene.Scene;import javafx.scene.paint.Paint;import javafx.scene.text.Text;import javafx.scene.text.TextAlignment;import javafx.scene.text.TextFlow;import javafx.stage.Stage;public class Main1 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Text t1 = new Text(&quot;javafx学习\\n&quot;);        t1.setStyle(&quot;-fx-font-size: 30;&quot; +                    &quot;-fx-fill: #fff;&quot;);        Text t2 = new Text(&quot;javafx学习1\\n&quot;);        t2.setStyle(&quot;-fx-fill: #f00;&quot; +                    &quot;-fx-font-size: 20;&quot;);        Text t3 = new Text(&quot;javafx学习2&quot;);        t3.setStyle(&quot;-fx-fill: #0f0;&quot; +                    &quot;-fx-font-size: 20;&quot;);        TextFlow textFlow = new TextFlow();        textFlow.setStyle(&quot;-fx-background-color: #567;&quot;);        textFlow.getChildren().addAll(t1,t2,t3);        textFlow.setPadding(new Insets(100));//设置补白        textFlow.setTextAlignment(TextAlignment.CENTER);//对齐方式        textFlow.setLineSpacing(30);//行间距        Scene scene = new Scene(textFlow);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;\n\nTilePane    瓦片布局\nimport javafx.application.Application;import javafx.geometry.Insets;import javafx.geometry.Orientation;import javafx.geometry.Pos;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.layout.TilePane;import javafx.stage.Stage;public class Main2 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;button1&quot;);        Button b2 = new Button(&quot;button2&quot;);        Button b3 = new Button(&quot;button3&quot;);        Button b4 = new Button(&quot;button4&quot;);        Button b5 = new Button(&quot;button5&quot;);        Button b6 = new Button(&quot;button6&quot;);//        瓦片布局,瓦片的每一片都是一样的        TilePane tilePane = new TilePane();        tilePane.setStyle(&quot;-fx-background-color: #567;&quot;);        tilePane.getChildren().addAll(b1, b2, b3, b4, b5, b6);//        水平和垂直间距        tilePane.setHgap(10);        tilePane.setVgap(10);//        设置padding        tilePane.setPadding(new Insets(10));//        设置子组件定位        tilePane.setAlignment(Pos.CENTER);//        设置某个子组件的margin,受布局的影响所有的子组件都会有margin        TilePane.setMargin(b1,new Insets(50));//        默认排列方向        tilePane.setOrientation(Orientation.VERTICAL);//        所有的子组件占的地方都会一样        b1.setPrefHeight(100);        b1.setPrefWidth(100);        Scene scene = new Scene(tilePane);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;\n\n"},{"title":"JavaFX学习之窗口常用方法","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"窗口常用方法JavaFX的第二次接触\n  一些操作窗口的常用方法  \n  primaryStage.setTitle(“Stage”);//窗口标题\n  primaryStage.setWidth(500);//设置宽度\n  primaryStage.setHeight(400);//设置高度\n  primaryStage.show();//显示窗口\n  primaryStage.setX(200);//设置窗口距屏幕左上角x轴的距离\n  primaryStage.setY(200);//设置窗口距屏幕左上角y轴的距离\n  等……\n\nimport javafx.application.Application;import javafx.beans.value.ChangeListener;import javafx.beans.value.ObservableValue;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.image.Image;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        primaryStage.setTitle(&quot;Stage&quot;);//窗口标题        primaryStage.getIcons().add(new Image(&quot;org/javafx/lesson2/icon/fz.png&quot;));//窗口图标//        primaryStage.setIconified(true);//设置启动窗口之后直接最小化//        primaryStage.setMaximized(true);//设置启动窗口之后直接最大化        primaryStage.setWidth(500);//设置宽度        primaryStage.setHeight(400);//设置高度////        primaryStage.setMaxWidth(800);//设置最大宽度//        primaryStage.setMaxHeight(500);//设置最大高度////        primaryStage.setMinWidth(300);//设置最小宽度//        primaryStage.setMinHeight(200);//设置最小高度//        primaryStage.setResizable(false);//不允许拉伸窗口        primaryStage.setOpacity(0.5);//设置窗口透明度        //        primaryStage.setAlwaysOnTop(false);//设置窗口是否置顶,false是不置顶        primaryStage.setX(200);//设置窗口距屏幕左上角x轴的距离        primaryStage.setY(200);//设置窗口距屏幕左上角y轴的距离        primaryStage.show();//显示窗口//        要在窗口显示后获取,不然获取不到//       System.out.println(&quot;宽度: &quot; + primaryStage.getWidth());//        System.out.println(&quot;高度: &quot; + primaryStage.getHeight());//        监听宽度变化        primaryStage.widthProperty().addListener(new ChangeListener&lt;Number&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) &#123;                System.out.println(&quot;当前宽度: &quot; + newValue.doubleValue());            &#125;        &#125;);//        监听高度变化        primaryStage.heightProperty().addListener(new ChangeListener&lt;Number&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) &#123;                System.out.println(&quot;当前高度: &quot; + newValue.doubleValue());            &#125;        &#125;);//        监听X轴坐标        primaryStage.xProperty().addListener(new ChangeListener&lt;Number&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends Number&gt; observable, Number oldValue, Number newValue) &#123;                System.out.println(&quot;当前X坐标: &quot; + newValue.doubleValue());            &#125;        &#125;);//        监听Y轴坐标        primaryStage.yProperty().addListener((observable, oldValue, newValue) -&gt; &#123;            System.out.println(&quot;当前Y坐标: &quot; + newValue.doubleValue());        &#125;);//        primaryStage.setFullScreen(true);//设置全屏,必须设置Scene//        primaryStage.setScene(new Scene(new Group()));//        primaryStage.close();//关闭窗口    &#125;&#125;\n\n"},{"title":"JavaFX学习之文本框密码框和Label标签","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E6%9C%AC%E6%A1%86%E5%AF%86%E7%A0%81%E6%A1%86%E5%92%8CLabel%E6%A0%87%E7%AD%BE/","content":"JavaFX的第八次接触\n文本框、密码框基本使用\n Label标签基本使用\n\nimport javafx.application.Application;import javafx.beans.value.ChangeListener;import javafx.beans.value.ObservableValue;import javafx.event.ActionEvent;import javafx.event.EventHandler;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.Label;import javafx.scene.control.PasswordField;import javafx.scene.control.TextField;import javafx.scene.control.Tooltip;import javafx.scene.text.Font;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        TextField text = new TextField();//输入框        TextField text1 = new TextField();//输入框        PasswordField pwd = new PasswordField();//密码输入框        Label label = new Label(&quot;这是Label标签&quot;);//Label标签        label.setStyle(&quot;-fx-text-fill: #fff;&quot; +                &quot;-fx-background-color: #567;&quot; +                &quot;-fx-font-size: 20;&quot;);        label.setLayoutX(10);        label.setLayoutY(20);        label.setOnMouseClicked(e -&gt; &#123;            System.out.println(&quot;鼠标单击Label事件&quot;);        &#125;);        text.setLayoutX(50);        text.setLayoutY(50);        text.setPrefWidth(300);        text.setPrefHeight(50);        text.setPromptText(&quot;这是没有输入文本时的提示信息&quot;);//输入框里的提示信息,失去焦点才会显示        text.setFocusTraversable(false);//设置文本框默认没有焦点        text.setStyle(&quot;-fx-background-color: #456;&quot; +                &quot;-fx-text-fill: #fff;&quot; +                &quot;-fx-font-size: 14;&quot;);        Tooltip tip1 = new Tooltip(&quot;这是提示&quot;);//鼠标放上输入框提示        tip1.setFont(Font.font(40));        text.setTooltip(tip1);//        文本监听        text.textProperty().addListener(new ChangeListener&lt;String&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) &#123;//                限制输入文字长度                if (newValue.length() &gt;= 7) &#123;                    text.setText(oldValue);                &#125;            &#125;        &#125;);//        监听鼠标选中输入框文字        text.selectedTextProperty().addListener(new ChangeListener&lt;String&gt;() &#123;            @Override            public void changed(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) &#123;                System.out.println(&quot;当前选中文字: &quot; + newValue);            &#125;        &#125;);//        选中输入框回车事件        text.setOnAction(new EventHandler&lt;ActionEvent&gt;() &#123;            @Override            public void handle(ActionEvent event) &#123;                System.out.println(&quot;选中输入框回车事件&quot;);            &#125;        &#125;);//        密码框        pwd.setLayoutX(50);        pwd.setLayoutY(110);        pwd.setPrefHeight(50);        pwd.setPromptText(&quot;这是没有输入文本时的密码框&quot;);        pwd.setPrefWidth(300);        pwd.setStyle(&quot;-fx-background-color: #789;&quot; +                &quot;-fx-text-fill: #fff;&quot;);        Tooltip tip3 = new Tooltip(&quot;这里是密码框&quot;);        pwd.setTooltip(tip3);//        密码框监听与文本框一致        pwd.textProperty().addListener((observable, oldValue, newValue) -&gt; &#123;            System.out.println(&quot;当前输入的文本: &quot; + newValue);        &#125;);        pwd.selectedTextProperty().addListener((o, oldV, newV) -&gt; &#123;            System.out.println(&quot;当前选中文字: &quot; + newV);        &#125;);        text1.setLayoutX(400);        text1.setLayoutY(50);        text1.setPrefWidth(300);        text1.setPrefHeight(50);        text1.setPromptText(&quot;这是没有输入文本时的提示信息&quot;);//输入框里的提示信息,失去焦点才会显示        text1.setStyle(&quot;-fx-background-color: #234;&quot; +                &quot;-fx-text-fill: #fff;&quot; +                &quot;-fx-font-size: 14;&quot;);        Tooltip tip2 = new Tooltip(&quot;这是提示&quot;);//鼠标放上输入框提示        tip2.setFont(Font.font(40));        text1.setTooltip(tip2);        Group group = new Group();        group.getChildren().addAll(text, text1, label, pwd);        Scene scene = new Scene(group);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(600);        primaryStage.show();    &#125;&#125;\n\n\n\n"},{"title":"JavaFX学习之舞台初体验","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%88%9E%E5%8F%B0%E5%88%9D%E4%BD%93%E9%AA%8C/","content":"JavaFX的第四次接触\n 布置场景、放置节点\n 设置鼠标样式(自定义图标)\n 用默认浏览器打开网页\n\nimport javafx.application.Application;import javafx.application.HostServices;import javafx.scene.Cursor;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.stage.Stage;import java.net.URL;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;//        使用默认浏览器打开网页        HostServices services = getHostServices();        services.showDocument(&quot;https://da9527.gitee.io&quot;);        Button button = new Button(&quot;我是一个按钮&quot;);//演员//        设置按钮宽高        button.setPrefWidth(200);        button.setPrefHeight(100);        button.setCursor(Cursor.HAND);//设置鼠标放上按钮时的形状,其他类似        Group root = new Group();//舞台上的场地,用来放置演员        root.getChildren().add(button);//放置演员        Scene scene = new Scene(root);//设置舞台//        获取图片路径,最好把图片文件放到src目录下        URL url = getClass().getClassLoader().getResource(&quot;icon/fz.png&quot;);        assert url != null;//指针有效性检验//        转成字符串        String s = url.toExternalForm();        scene.setCursor(Cursor.cursor(s));//设置鼠标放上舞台后的样式,自定义图片        primaryStage.setScene(scene);//放置舞台        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(400);        primaryStage.show();    &#125;&#125;\n\n"},{"title":"JavaFX学习之窗口常用方法二","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AA%97%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%BA%8C/","content":"窗口常用方法二JavaFX的第三次接触\n 窗口的显示\n Platform类的简单使用\n\n窗口样式\nimport javafx.application.Application;import javafx.application.Platform;import javafx.stage.Stage;import javafx.stage.StageStyle;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;//        Stage s1 = new Stage();//        s1.setTitle(&quot;s1&quot;);//        s1.initStyle(StageStyle.DECORATED);//默认显示状态//        s1.show();//        Stage s2 = new Stage();//        s2.setTitle(&quot;s2&quot;);//        s2.initStyle(StageStyle.TRANSPARENT);//显示状态为透明//        s2.show();//        Stage s3 = new Stage();//        s3.setTitle(&quot;s3&quot;);//        s3.initStyle(StageStyle.UNDECORATED);//显示状态为透明,与TRANSPARENT效果一样//        s3.show();//        Stage s4 = new Stage();//        s4.setTitle(&quot;s4&quot;);//        s4.initStyle(StageStyle.UNIFIED);//自动填充其他背景为白色//        s4.show();        Stage s5 = new Stage();        s5.setTitle(&quot;s5&quot;);        s5.initStyle(StageStyle.UTILITY);//没有最大化最小化按钮,只有关闭按钮        s5.show();//        Platform.exit();//关闭所有窗口    &#125;&#125;\n\n\n\n窗口模态\nimport javafx.application.Application;import javafx.stage.Modality;import javafx.stage.Stage;public class Main1 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Stage s1 = new Stage();        s1.setTitle(&quot;s1&quot;);        s1.show();        Stage s2 = new Stage();        s2.setTitle(&quot;s2&quot;);        s2.initOwner(s1);//设置s2与s1关联上        s2.initModality(Modality.WINDOW_MODAL);//关联之后不能越过s2操作s1        s2.show();        Stage s3 = new Stage();        s3.setTitle(&quot;s3&quot;);        s3.initModality(Modality.APPLICATION_MODAL);//不能越过s3去操作s1和s2        s3.show();    &#125;&#125;\n\n\n\nPlatform的runLater方法简单使用\nimport javafx.application.Application;import javafx.application.Platform;import javafx.stage.Stage;public class Main2 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;//        可以在run方法里更新界面组件,不要做大量操作        Platform.runLater(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;Platform.runLater线程名字 =&gt; &quot; + Thread.currentThread().getName());            &#125;        &#125;);        System.out.println(&quot;Platform.runLater下面线程名字 =&gt; &quot; + Thread.currentThread().getName());    &#125;&#125;\n\n\n\nPlatform获取屏幕信息\nimport javafx.application.Application;import javafx.application.ConditionalFeature;import javafx.application.Platform;import javafx.geometry.Rectangle2D;import javafx.stage.Screen;import javafx.stage.Stage;public class Main3 extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;//        Platform.setImplicitExit(false);//设置为false关闭窗口程序还是会在后台运行,默认为true        System.out.println(Platform.isSupported(ConditionalFeature.SCENE3D));//是否支持3D        System.out.println(Platform.isSupported(ConditionalFeature.FXML));//是否支持FXML        Screen screen = Screen.getPrimary();        System.out.println(&quot;当前屏幕dpi: &quot; + screen.getDpi());        Rectangle2D sc1 = screen.getBounds();//获取屏幕所有的坐标        Rectangle2D sc2 = screen.getVisualBounds();//获取可视区域所有的坐标        System.out.println(&quot;全部屏幕的宽高&quot;);        System.out.println(&quot;左上角x坐标: &quot; + sc1.getMinX() + &quot; , 左上角y坐标: &quot; + sc1.getMinY());        System.out.println(&quot;右下角x坐标: &quot; + sc1.getMaxX() + &quot; , 右下角y坐标: &quot; + sc1.getMaxY());        System.out.println(&quot;宽度: &quot; + sc1.getWidth() + &quot; , 高度: &quot; + sc1.getHeight());        System.out.println(&quot;可视屏幕的宽高&quot;);//少的部分是任务栏的高度        System.out.println(&quot;左上角x坐标: &quot; + sc2.getMinX() + &quot; , 左上角y坐标: &quot; + sc2.getMinY());        System.out.println(&quot;右下角x坐标: &quot; + sc2.getMaxX() + &quot; , 右下角y坐标: &quot; + sc2.getMaxY());        System.out.println(&quot;宽度: &quot; + sc2.getWidth() + &quot; , 高度: &quot; + sc2.getHeight());        primaryStage.show();//        Platform.exit();//setImplicitExit设置为false之后需要使用这个才能完全关闭程序    &#125;&#125;\n\n"},{"title":"JavaFX学习之按钮点击事件与快捷键绑定","url":"/2021/05/22/JavaFX%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%91%E5%AE%9A/","content":"JavaFX的第七次接触\n 按键单击、多击事件\n 快捷键绑定\n\nimport javafx.application.Application;import javafx.event.EventHandler;import javafx.scene.Group;import javafx.scene.Scene;import javafx.scene.control.Button;import javafx.scene.input.*;import javafx.stage.Stage;public class Main extends Application &#123;    public static void main(String[] args) &#123;        launch(args);    &#125;    @Override    public void start(Stage primaryStage) throws Exception &#123;        Button b1 = new Button(&quot;b1&quot;);        b1.setPrefWidth(200);        b1.setPrefHeight(100);        b1.setLayoutX(10);        b1.setLayoutY(10);        b1.setStyle(&quot;-fx-font-size: 20;&quot; +                    &quot;-fx-text-fill: #fff;&quot; +                    &quot;-fx-background-color: #2ecc71;&quot;);        Button b2 = new Button(&quot;b2&quot;);        b2.setPrefWidth(200);        b2.setPrefHeight(100);        b2.setLayoutX(220);        b2.setLayoutY(10);        b2.setStyle(&quot;-fx-font-size: 20;&quot; +                    &quot;-fx-text-fill: #fff;&quot; +                    &quot;-fx-background-color: #8e44ad;&quot;);//        第一种鼠标左键单击事件        b1.setOnAction(e -&gt; &#123;            System.out.println(((Button)e.getSource()).getText() + &quot;的单击事件&quot;);        &#125;);//        第二种鼠标单击事件与鼠标双击事件(多击事件)        b1.addEventHandler(MouseEvent.MOUSE_CLICKED, new EventHandler&lt;MouseEvent&gt;() &#123;            @Override            public void handle(MouseEvent event) &#123;//                System.out.println(&quot;addEventHandler事件鼠标单击&quot;);//                System.out.println(&quot;当前鼠标按键 =&gt; &quot; + event.getButton().name());//event.getButton().name()获取哪个鼠标按键点的//                if (event.getClickCount() == 2)&#123;//判断鼠标点击的次数//                    System.out.println(&quot;鼠标双击了...&quot;);//                &#125;                if (event.getClickCount() == 3)&#123;                    System.out.println(&quot;鼠标3击了...&quot;);                &#125;//                鼠标右键双击触发                if (event.getClickCount() == 2 &amp;&amp; event.getButton().name().equals(MouseButton.SECONDARY.name()))&#123;                    System.out.println(&quot;鼠标右键双击了&quot;);                &#125;            &#125;        &#125;);//        lambda写法        b2.addEventHandler(MouseEvent.MOUSE_CLICKED,e -&gt; &#123;            if (e.getClickCount() == 2 &amp;&amp; e.getButton().name().equals(MouseButton.PRIMARY.name()))&#123;                System.out.println(&quot;鼠标左键双击&quot;);            &#125;        &#125;);//        监听键盘事件,点击了之后才会监听        b2.setOnKeyPressed(new EventHandler&lt;KeyEvent&gt;() &#123;            @Override            public void handle(KeyEvent event) &#123;                System.out.println(event.getCode().getName() + &quot;按下&quot;);                if (event.getCode().name().equals(KeyCode.Q.name()))&#123;//条件过滤                    System.out.println(&quot;Q按下了...&quot;);                &#125;            &#125;        &#125;);        b2.setOnKeyReleased(new EventHandler&lt;KeyEvent&gt;() &#123;            @Override            public void handle(KeyEvent event) &#123;                System.out.println(event.getCode().getName() + &quot;释放&quot;);            &#125;        &#125;);        Group group = new Group();        group.getChildren().addAll(b1,b2);        Scene scene = new Scene(group);//        设置快捷键//        第一种方式        KeyCodeCombination kc1 = new KeyCodeCombination(KeyCode.C, KeyCombination.ALT_DOWN, KeyCombination.CONTROL_DOWN);        Mnemonic mc1 = new Mnemonic(b1, kc1);//绑定b1按钮的点击事件        scene.addMnemonic(mc1);//        第二种方式        KeyCharacterCombination kc2 = new KeyCharacterCombination(&quot;O&quot;, KeyCombination.ALT_DOWN);        Mnemonic mc2 = new Mnemonic(b1, kc2);//绑定b1按钮的点击事件        scene.addMnemonic(mc2);//        第三种,太长略过//        第四种,这种方式比较推荐,可以写逻辑        KeyCodeCombination kc4 = new KeyCodeCombination(KeyCode.Y, KeyCombination.SHIFT_DOWN);        scene.getAccelerators().put(kc4, new Runnable() &#123;            @Override            public void run() &#123;//                虽然有Runnable当是不是新的线程                System.out.println(&quot;run方法&quot; + Thread.currentThread().getName());                b1.fire();//执行b1按钮的单击事件            &#125;        &#125;);        primaryStage.setScene(scene);        primaryStage.setTitle(&quot;javafx&quot;);        primaryStage.setWidth(800);        primaryStage.setHeight(500);        primaryStage.show();    &#125;&#125;\n\n"},{"title":"SpringAop的使用","url":"/2021/05/15/SpringAop%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"SpringAop的使用什么是 AOP\nAOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。\n为什么需要 AOP\n如果在开发中有多个模块间有某段重复的代码，在面向过程编程中，我们会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。但是功能总是变化的。要想新增一个功能，需要在多处做修改，要想再抽象出一个方法，然后又需要在需要的地方分别调用这个方法，又或者不需要这个方法了，又要去删除掉每一处调用该方法的地方，想想都觉得繁琐，实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。\n使用注解使用SpringAop\n1、引入aop的依赖(spring框架肯定会要引入spring的依赖，不是只要下面的aop依赖)\n&lt;!--        aop依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.6&lt;/version&gt;        &lt;/dependency&gt;\n2、在配置文件中添加约束、自动扫描、aop代理\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                        http://www.springframework.org/schema/beans/spring-beans.xsd                        http://www.springframework.org/schema/context                        http://www.springframework.org/schema/context/spring-context.xsd                        http://www.springframework.org/schema/aop                        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--    自动扫描 base-package=&quot;你要扫描的包&quot;--&gt;    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;    &lt;!--    配置aop代理--&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;\n3、准备一个Dog类\nimport org.springframework.stereotype.Component;@Componentpublic class Dog &#123;    public void say()&#123;        System.out.println(&quot;汪汪汪...&quot;);//        int i = 1/0;//测试异常通知    &#125;&#125;\n4、准备一个切面类\nimport org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component //将对象交给springIOC容器管理@Aspect //声明当前类是一个切面public class DogAspect &#123;    /*     *   切入点，定义要拦截哪些类的哪些方法     *       @Pointcut 定义切入点@Pointcut(&quot;匹配规则&quot;)     *           aop切入点表达式 &quot;execution(* com.demo.*.*(..))&quot;     *           第一个 * 代表的是方法的修饰范围(public、private、protected) * 号表示所有范围     *           aop切入点表达式的常用方法     *           1、执行所有的公共方法     *               execution(public *(..))     *           2、执行任意的set方法     *               execution(* set*(..))     *           3、设置指定包下的任意类的任意方法,指定包(com.demo)     *               execution(* com.demo.*.*(..))     *           4、设置指定包及其子包下的任意类的任意方法,指定包(com.demo)     *               execution(* com.demo..*.*(..))     *  */    @Pointcut(&quot;execution(* com.demo.*.*(..))&quot;)    public void cut() &#123;&#125;    //    声明前置通知//        目标类方法执行前,执行该通知    @Before(value = &quot;cut()&quot;)    public void before() &#123;        System.out.println(&quot;前置通知...&quot;);    &#125;    //    声明返回通知//        目标类方法无异常执行后,执行该通知    @AfterReturning(value = &quot;cut()&quot;)    public void afterReturn() &#123;        System.out.println(&quot;返回通知...&quot;);    &#125;    //    声明最终通知//        目标类方法执行后,执行该通知(有无异常都会执行)    @After(value = &quot;cut()&quot;)    public void after() &#123;        System.out.println(&quot;最终通知...&quot;);    &#125;    //    声明异常通知//        目标类方法执行异常,执行该通知    @AfterThrowing(value = &quot;cut()&quot;, throwing = &quot;e&quot;)    public void tThorw(Exception e) &#123;        System.out.println(&quot;异常通知 ==&gt; &quot; + e.getMessage());    &#125;    //    声明环绕通知//        目标类方法执行前后,都可以通过环绕通知定义响应的处理//        需要通过显示调用的方法,否则无法访问指定的方法 pjp.proceed()    @Around(value = &quot;cut()&quot;)    public Object around(ProceedingJoinPoint pjp) &#123;        System.out.println(&quot;环绕通知-前置通知...&quot;);        Object o = null;        try &#123;//            显示调用对应的方法            o = pjp.proceed();            System.out.println(&quot;环绕通知-返回通知...&quot;);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;环绕通知-异常通知 ==&gt;&quot; + throwable.getMessage());        &#125;        System.out.println(&quot;环绕通知-最终通知...&quot;);        return o;    &#125;&#125;\n5、测试\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Dog dog = (Dog) context.getBean(&quot;dog&quot;);        dog.say();    &#125;&#125;\n\n使用配置文件使用SpringAop\n把切面类修改一下(删掉切面相关的注解)\nimport org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component //将对象交给springIOC容器管理public class DogAspect &#123;    /*     *   切入点，定义要拦截哪些类的哪些方法     *       @Pointcut 定义切入点@Pointcut(&quot;匹配规则&quot;)     *           aop切入点表达式 &quot;execution(* com.demo.*.*(..))&quot;     *           第一个 * 代表的是方法的修饰范围(public、private、protected) * 号表示所有范围     *           aop切入点表达式的常用方法     *           1、执行所有的公共方法     *               execution(public *(..))     *           2、执行任意的set方法     *               execution(* set*(..))     *           3、设置指定包下的任意类的任意方法,指定包(com.demo)     *               execution(* com.demo.*.*(..))     *           4、设置指定包及其子包下的任意类的任意方法,指定包(com.demo)     *               execution(* com.demo..*.*(..))     *  */    public void cut() &#123;&#125;    //    声明前置通知//        目标类方法执行前,执行该通知    public void before() &#123;        System.out.println(&quot;前置通知...&quot;);    &#125;    //    声明返回通知//        目标类方法无异常执行后,执行该通知    public void afterReturn() &#123;        System.out.println(&quot;返回通知...&quot;);    &#125;    //    声明最终通知//        目标类方法执行后,执行该通知(有无异常都会执行)    public void after() &#123;        System.out.println(&quot;最终通知...&quot;);    &#125;    //    声明异常通知//        目标类方法执行异常,执行该通知    public void tThorw(Exception e) &#123;        System.out.println(&quot;异常通知 ==&gt; &quot; + e.getMessage());    &#125;    //    声明环绕通知//        目标类方法执行前后,都可以通过环绕通知定义响应的处理//        需要通过显示调用的方法,否则无法访问指定的方法 pjp.proceed()    public Object around(ProceedingJoinPoint pjp) &#123;        System.out.println(&quot;环绕通知-前置通知...&quot;);        Object o = null;        try &#123;//            显示调用对应的方法            o = pjp.proceed();            System.out.println(&quot;环绕通知-返回通知...&quot;);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;环绕通知-异常通知 ==&gt;&quot; + throwable.getMessage());        &#125;        System.out.println(&quot;环绕通知-最终通知...&quot;);        return o;    &#125;&#125;\n在配置文件配置\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                        http://www.springframework.org/schema/beans/spring-beans.xsd                        http://www.springframework.org/schema/context                        http://www.springframework.org/schema/context/spring-context.xsd                        http://www.springframework.org/schema/aop                        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--    自动扫描 base-package=&quot;你要扫描的包&quot;--&gt;    &lt;context:component-scan base-package=&quot;com.demo&quot;/&gt;&lt;!--    aop手动配置--&gt;    &lt;aop:config&gt;&lt;!--        aop切面--&gt;        &lt;aop:aspect ref=&quot;DogAspect&quot;&gt;&lt;!--            定义切入点--&gt;       &lt;aop:pointcut id=&quot;cut&quot; expression=&quot;execution(* com.demo.*.*(..))&quot;/&gt;&lt;!--            定义前置通知--&gt;            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;cut&quot;/&gt;&lt;!--            定义返回通知--&gt;            &lt;aop:after method=&quot;afterReturn&quot; pointcut-ref=&quot;cut&quot;/&gt;&lt;!--            定义最终通知--&gt;            &lt;aop:after-returning method=&quot;after&quot; pointcut-ref=&quot;cut&quot;/&gt;&lt;!--            定义异常通知--&gt;            &lt;aop:after-throwing method=&quot;tThorw&quot; pointcut-ref=&quot;cut&quot; throwing=&quot;e&quot;/&gt;&lt;!--            定义环绕通知--&gt;            &lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;cut&quot;/&gt;        &lt;/aop:aspect&gt;&lt;/beans&gt;\n测试\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Dog dog = (Dog) context.getBean(&quot;dog&quot;);        dog.say();    &#125;&#125;\n\n"},{"title":"cglib动态代理","url":"/2021/05/13/cglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"cglib动态代理cglib与Jdk代理的区别\n Jdk动态代理实现接口，cglib动态代理是继承思想\n 如果目标对象存在接口， Jdk动态代理执行效率高于cglib动态代理(当目标对象存在接口应当优先选择 Jdk动  态代理)\n\n操作步骤\n1、 导入cglib依赖\n\n2、 新建目标类\n\n3、 创建代理类\n\n4、 测试\n\n\n1、 导入cglib依赖 &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt;    &lt;groupId&gt;cglib&lt;/groupId&gt;    &lt;artifactId&gt;cglib&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;\n\n2、 新建目标类package com.demo.proxy;public class Dog &#123;    public void say()&#123;        System.out.println(&quot;汪汪汪......&quot;);    &#125;&#125;\n\n3、 创建代理类(实现 MethodInterceptor接口)package com.demo.proxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibProxy implements MethodInterceptor &#123;    //    要代理的目标类    private Object terget;    public CglibProxy(Object terget) &#123;        this.terget = terget;    &#125;    //    获取代理对象    public Object getProxy()&#123;//        通过Enhancer对象中的create()方法生成一个类,用于生成代理对象        Enhancer enhancer = new Enhancer();//        设置父类 (将目标类作为代理类的父类)        enhancer.setSuperclass(terget.getClass());//        设置拦截器,回调对象为本身对象        enhancer.setCallback(this);//        生成代理类对象并返回        return enhancer.create();    &#125;//    拦截器(用于调用或增强目标方法)//    intercept(cglib动态生成的代理类实例,实体类的方法,参数列表,生成代理类对方法的代理引用)    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;        //        增强行为        System.out.println(&quot;有陌生人来了&quot;);        Object o1 = methodProxy.invoke(terget, objects);        //        增强行为        System.out.println(&quot;陌生人走了,狗不叫了......&quot;);        return o1;    &#125;&#125;\n\n4、 测试package com.demo.proxy;public class ProxyTest &#123;    public static void main(String[] args) &#123;        Dog proxy = (Dog) new CglibInterceptor(new Dog()).getProxy();        proxy.say();    &#125;&#125;\n\n"},{"title":"Java设计模式之工厂模式","url":"/2021/05/14/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"Java设计模式之工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n一个类若是选择静态工厂，那么一般会把创建方法标志成私有的，而用创建方法去调用（比如，getInstance）。这会影响其子类化的可实现性。\n静态工厂模式准备接口\npublic interface Animal &#123;    void say();&#125;\n\n接口实现类(使用单例模式，不让直接new出来)\npublic class Dog implements Animal &#123;\t    private Dog() &#123;    &#125;    public static Dog getInstance() &#123;        return new Dog();    &#125;    @Override    public void say() &#123;        System.out.println(&quot;汪汪汪...&quot;);    &#125;&#125;\n\npublic class Cat implements Animal&#123;    private Cat()&#123;&#125;    public static Cat getInstance()&#123;        return new Cat();    &#125;    @Override    public void say() &#123;        System.out.println(&quot;喵喵喵...&quot;);    &#125;&#125;\n\n静态工厂\npublic class Factory &#123;    public Animal getAnimal(String name)&#123;        if (&quot;dog&quot;.equals(name))&#123;            return Dog.getInstance();        &#125;else if (&quot;cat&quot;.equals(name))&#123;            return Cat.getInstance();        &#125;else &#123;            return null;        &#125;    &#125;&#125;\n\n测试\npublic class Test &#123;    public static void main(String[] args) &#123;        Factory factory = new Factory();        Animal dog = factory.getAnimal(&quot;dog&quot;);        Animal cat = factory.getAnimal(&quot;cat&quot;);        dog.say();        cat.say();    &#125;&#125;\n\n\n\n工厂方法模式准备接口\npublic interface Animal &#123;    void say();&#125;\n\npublic interface AnimalFactory &#123;    Animal getAnimal();&#125;\n\n实现类\n​    实现Animal的实现类\npublic class Dog implements Animal &#123;\t    private Dog() &#123;    &#125;    public static Dog getInstance() &#123;        return new Dog();    &#125;    @Override    public void say() &#123;        System.out.println(&quot;汪汪汪...&quot;);    &#125;&#125;\n\npublic class Cat implements Animal&#123;    private Cat()&#123;&#125;    public static Cat getInstance()&#123;        return new Cat();    &#125;    @Override    public void say() &#123;        System.out.println(&quot;喵喵喵...&quot;);    &#125;&#125;\n\n​    实现AnimalFactory的实现类\npublic class DogFactor implements AnimalFactory&#123;    @Override    public Animal getAnimal() &#123;        return Dog.getInstance();    &#125;&#125;\n\npublic class CatFactory implements AnimalFactory&#123;    @Override    public Animal getAnimal() &#123;        return Cat.getInstance();    &#125;&#125;\n\n测试类\npublic class Test &#123;    public static void main(String[] args) &#123;        Animal dog = new DogFactor().getAnimal();        Animal cat = new CatFactory().getAnimal();        dog.say();        cat.say();    &#125;&#125;\n\n\n\n"},{"title":"Jdk动态代理","url":"/2021/05/13/Jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"JDK动态代理JDK动态代理是代理模式的一种实现方式，其只能代理（接口）。\n  操作步骤\n​    1、 新建接口\n​    2、 为接口创建实现类\n​    3、 创建代理类实现接口\n​    4、 测试\n\n1、 新建接口package com.demo.proxy;public interface Eat &#123;    void eat();&#125;\n\n2、 为接口创建实现类package com.demo.proxy;public class Person implements Eat&#123;    @Override    public void eat() &#123;        System.out.println(&quot;吃饭......&quot;);    &#125;&#125;\n\n3、 创建代理类实现接口(代理类要实现InvocationHandler接口)package com.demo.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class JdkProxy implements InvocationHandler &#123;    private Object target;    //    通过构造器获取要代理的实例接口的对象    public JdkProxy(Object target) &#123;        this.target = target;    &#125;    //    通过代理类获取代理对象//    Proxy.newProxyInstance(类加载器,接口数组,实现InvocationHandler接口的实现类(this))    public Object getProxy() &#123;        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    &#125;    //    要增加功能的地方    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;//        方法增强        System.out.println(&quot;去食堂......&quot;);        Object obj = method.invoke(target, args);//method.invoke(传来的参数对象, 方法参数)//        方法增强        System.out.println(&quot;吃完回宿舍......&quot;);        return obj;    &#125;&#125;\n\n4、 测试package com.demo.proxy;public class ProxyTest &#123;    public static void main(String[] args) &#123;        //强制转换的是接口类型，不是接口的实现类        Eat proxy = (Eat) new JdkProxy(new Person()).getProxy();        proxy.eat();    &#125;&#125;\n\n\n\n"},{"title":"java注解","url":"/2021/04/24/java%E6%B3%A8%E8%A7%A3/","content":"Java注解内置注解@Override//@Override重写的注解public String toString() &#123;    return super.toString();&#125;@Deprecated//@Deprecated不推荐程序员使用,但是可以使用,或者存在更好的方式public static void test()&#123;    System.out.println(&quot;@Deprecated&quot;);&#125;@SuppressWarnings(&quot;all&quot;)//@SuppressWarnings(&quot;all&quot;)镇压警告public void test01()&#123;    ArrayList list = new ArrayList();&#125;\n\n元注解@Target 表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中，包括：     ElemenetType.CONSTRUCTOR-----------------------------构造器声明      ElemenetType.FIELD ----------------------------------域声明（包括 enum 实例）      ElemenetType.LOCAL_VARIABLE------------------------- 局部变量声明      ElemenetType.METHOD ---------------------------------方法声明      ElemenetType.PACKAGE --------------------------------包声明      ElemenetType.PARAMETER ------------------------------参数声明      ElemenetType.TYPE----------------------------------- 类，接口（包括注解类型）或enum声明 @Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括：     RetentionPolicy.SOURCE-------------注解将被编译器丢弃      RetentionPolicy.CLASS -------------注解在class文件中可用，但会被VM丢弃      RetentionPolicy.RUNTIME ---------VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。@Documented 将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。@Inherited 允许子类继承父类中的注解。\n\n元注解的简单使用//定义一个注解//Target 表示我们的注解可以用在什么地方@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 表示我们的注解在什么地方还有效  runtime &gt; class &gt; sources@Retention(value = RetentionPolicy.RUNTIME)//Documented 表示是否将我们的注解生成在javadoc中@Documented//Inherited 表示子类可以继承父类的注解@Inherited@interface MyAnnotation&#123; &#125;\n\n自定义注解public class Test01 &#123;//    注解可以显示赋值,如果没有默认值,我们就必须给注解赋值,否则就会报错    @MyAnnotation1(name = &quot;da&quot;,schools = &#123;&quot;哔哩哔哩大学&quot;&#125;)    public void test()&#123;&#125;    @MyAnnotation2(&quot;da&quot;)    public void test1()&#123;&#125;&#125;//自定义注解@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation1&#123;//    注解的参数: 参数类型 + 参数名 ();    String name() default &quot;&quot;;//可以定义默认值    int age() default 0;    int id() default -1;//如果默认值为-1代表不存在    String[] schools();&#125;@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2&#123;    String value();//如果只有一个参数最好用value&#125;\n\n"},{"title":"java定时任务","url":"/2021/05/15/java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"java定时任务1、TimerTimer 是 JDK 自带的定时任务执行类，优点是方便，缺点是任务如果执行时间太长或者是任务执行异常，会影响其他任务调度，所以在生产环境下建议谨慎使用。import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerTest &#123;    public static void main(String[] args) &#123;//        定时任务        TimeTask timeTask = new TimeTask();//        计时器        Timer t = new Timer();//        添加执行任务schedule(定时任务,延迟时间,执行时间间隔);        t.schedule(timeTask, 0, 2000);    &#125;&#125;class TimeTask extends TimerTask &#123;    @Override    public void run() &#123;        System.out.println(&quot;当前时间 =&gt; &quot; + new Date());    &#125;&#125;\n\n\n\n2、ScheduledExecutorServiceScheduledExecutorService 是 JDK 1.5 自带的 API，ScheduledExecutorService 可以实现 Timer 类具备的所有功能，并且它可以解决了 Timer 类存在的所有问题。只有当任务的执行时间到来时，ScheduedExecutor 才会真正启动一个线程，其余时间 ScheduledExecutor 都是在轮询任务的状态。\nimport java.util.Date;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;// 创建任务队列        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);// 10 为线程数量//       scheduleAtFixedRate(Runnable实现类,延时时间,间隔时间,给定单元粒度的时间段(下面会有说明));        scheduledExecutorService.scheduleAtFixedRate(new Task(), 0, 2, TimeUnit.SECONDS);    &#125;&#125;//任务类class Task implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(&quot;当前时间 =&gt; &quot; + new Date());    &#125;&#125;\n\nlambda表达式写法\nimport java.util.Date;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;            System.out.println(&quot;当前时间 =&gt; &quot; + new Date());        &#125;,0,2, TimeUnit.SECONDS);    &#125;&#125;\n\nTimeUnit是java.util.concurrent包下面的一个类，表示给定单元粒度的时间段，主要作用：时间颗粒度转换、延时常用的颗粒度\nTimeUnit.DAYS          //天TimeUnit.HOURS         //小时TimeUnit.MINUTES       //分钟TimeUnit.SECONDS       //秒TimeUnit.MILLISECONDS  //毫秒\n\n**时间颗粒度转换 **\npublic long toMillis(long d)    //转化成毫秒public long toSeconds(long d)  //转化成秒public long toMinutes(long d)  //转化成分钟public long toHours(long d)    //转化成小时public long toDays(long d)     //转化天\n\n时间颗粒度转换用法\nimport java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;//        一天有24个小时        System.out.println(TimeUnit.DAYS.toHours(1));//24//        一个小时有60分钟        System.out.println(TimeUnit.HOURS.toMinutes(1));//60//        一分钟有60秒        System.out.println(TimeUnit.MINUTES.toSeconds(1));//60//        一秒有1000毫秒        System.out.println(TimeUnit.SECONDS.toMillis(1));//1000//        把2天换算成小时(48小时)        System.out.println(TimeUnit.HOURS.convert(2,TimeUnit.DAYS));//48//        把2小时换算成分钟(120分钟)        System.out.println(TimeUnit.MINUTES.convert(2,TimeUnit.HOURS));//120    &#125;&#125;\n\n延时用法\nimport java.util.concurrent.TimeUnit;public class TimerTest &#123;    public static void main(String[] args) &#123;        new Thread(() -&gt; &#123;            try &#123;                TimeUnit.SECONDS.sleep(2);                System.out.println(&quot;过去了2秒&quot;);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;).start();    &#125;&#125;\n\n3、Spring Task如果使用的是 Spring 或 Spring Boot 框架，可以直接使用 Spring Framework 自带的定时任务，使用上面两种定时任务的实现方式，很难实现设定了具体时间的定时任务，比如当我们需要每周五来执行某项任务时，但如果使用 Spring Task 就可轻松的实现此需求。SprngTask没有专门的包，其核心类位于spring-context包中。所以引入spring的核心包此功能即可使用定时任务是自动触发的无需手动干预，也就是说 Spring 启动后会自动加载并执行定时任务。记得要引入task的schema\nxmlns:task=&quot;http://www.springframework.org/schema/task&quot;http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd\n\n基于注解的使用\n在配置文件中打开注解\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                        http://www.springframework.org/schema/beans/spring-beans.xsd                        http://www.springframework.org/schema/context                        http://www.springframework.org/schema/context/spring-context.xsd                        http://www.springframework.org/schema/task                        http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;&gt;&lt;!--    自动扫描--&gt;    &lt;context:component-scan base-package=&quot;com.demo1&quot;/&gt;&lt;!--    开启spring task注解模式--&gt;    &lt;task:annotation-driven/&gt;&lt;/beans&gt;\n\n任务类\nimport org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class Tasks &#123;\t//cron 表达式(下面介绍)    @Scheduled(cron = &quot;0/2 * * * * ?&quot;)    public void test()&#123;        System.out.println(&quot;我是定时任务1,当前时间为 =&gt; &quot; + new Date());    &#125;    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)    public void test1()&#123;        System.out.println(&quot;我是定时任务2,当前时间为 =&gt; &quot; + new Date());    &#125;&#125;\n\n测试类\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        //获取spring的上下文        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);        System.out.println(&quot;定时任务会自动启动...&quot;);    &#125;&#125;\n\n基于xml的使用\n配置xml文件\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans                        http://www.springframework.org/schema/beans/spring-beans.xsd                        http://www.springframework.org/schema/context                        http://www.springframework.org/schema/context/spring-context.xsd                        http://www.springframework.org/schema/task                        http://www.springframework.org/schema/task/spring-task-3.2.xsd&quot;&gt;&lt;!--    自动扫描--&gt;    &lt;context:component-scan base-package=&quot;com.demo1&quot;/&gt;&lt;!--    task xml配置 --&gt;    &lt;task:scheduled-tasks&gt;&lt;!--        第一个定时任务--&gt;        &lt;task:scheduled ref=&quot;tasks&quot; method=&quot;test&quot; cron=&quot;0/2 * * * * ?&quot;/&gt;&lt;!--        第二个定时任务--&gt;        &lt;task:scheduled ref=&quot;tasks&quot; method=&quot;test1&quot; cron=&quot;0/5 * * * * ?&quot;/&gt;    &lt;/task:scheduled-tasks&gt;&lt;/beans&gt;\n\n去掉任务类的注解\nimport org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class Tasks &#123;    public void test()&#123;        System.out.println(&quot;我是定时任务1,当前时间为 =&gt; &quot; + new Date());    &#125;    public void test1()&#123;        System.out.println(&quot;我是定时任务2,当前时间为 =&gt; &quot; + new Date());    &#125;&#125;\n\n测试\nimport org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring2.xml&quot;);        System.out.println(&quot;定时任务会自动启动...&quot;);    &#125;&#125;\n\nSpring Task 的实现需要使用 cron 表达式来声明执行的频率和规则，cron 表达式是由 6 位或者 7 位组成的（最后一位可以省略），每位之间以空格分隔，每位从左到右代表的含义如下：格式: [秒] [分] [小时] [日] [月] [周] [年]\n\n\n\n序号\n说明\n是否必填\n允许填写的值\n允许的通配符\n\n\n\n1\n秒\n是\n0-59\n, - * /\n\n\n2\n分\n是\n0-59\n, - * /\n\n\n3\n小时\n是\n0-23\n, - * /\n\n\n4\n日\n是\n1-31，要考虑月份的日期\n, - * ? / L W\n\n\n5\n月\n是\n1-12 或者 JAN-DEC\n, - * /\n\n\n6\n周\n是\n1-7 或者 SUN-SAT\n, - * ? / L #\n\n\n7\n年\n否\n1970-2099\n, - * /\n\n\n通配符说明:\n\n* 表示所有值. 例如:在分的字段上设置 “*”,表示每一分钟都会触发。\n ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10* ?\n - 表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。\n , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发\n / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。\n L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”\n W 表示离指定日期的最近那个工作日(周一至周五)\n ‘L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发\n # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置\n\n在线生成cron表达式的网站\n"},{"title":"java设计模式之单例模式","url":"/2021/05/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n介绍意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决：一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n饿汉式这种方式比较常用，但容易产生垃圾对象。\n它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\npublic class SingletonPattern &#123;    //饿汉式,类加载时就初始化，会浪费内存    private SingletonPattern() &#123;        System.out.println(&quot;SingletonPattern被实例化了&quot;);    &#125;        public static SingletonPattern getInstance() &#123;        return new SingletonPattern();    &#125;&#125;\n\n懒汉式，线程不安全\n这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。\npublic class SingletonPattern &#123;    private static SingletonPattern singletonPattern;    private SingletonPattern() &#123;        System.out.println(&quot;SingletonPattern被实例化了......&quot;);    &#125;    //    懒汉式单例，用的时候在实例化    public static SingletonPattern getInstance() &#123;        if (singletonPattern == null) &#123;            singletonPattern = new SingletonPattern();        &#125;        return singletonPattern;    &#125;&#125;\n\n懒汉式，线程安全(加锁)\n这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\npublic class SingletonPattern &#123;    private static SingletonPattern singletonPattern;    private SingletonPattern() &#123;        System.out.println(&quot;SingletonPattern被实例化了......&quot;);    &#125;    //    懒汉式单例,线程安全,加锁 synchronized 才能保证单例，但加锁会影响效率    public static synchronized SingletonPattern getInstance() &#123;        if (singletonPattern == null) &#123;            singletonPattern = new SingletonPattern();        &#125;        return singletonPattern;    &#125;&#125;\n\n懒汉式，线程安全（双检锁/双重校验锁（DCL，即 double-checked locking））\n这种方式采用双锁机制，安全且在多线程情况下能保持高性能。\npublic class SingletonPattern &#123;\t//\tvolatile锁    private static volatile SingletonPattern singletonPattern;    private SingletonPattern() &#123;        System.out.println(&quot;SingletonPattern被实例化了......&quot;);    &#125;    //  synchronized锁     public static synchronized SingletonPattern getInstance() &#123;        if (singletonPattern == null) &#123;            singletonPattern = new SingletonPattern();        &#125;        return singletonPattern;    &#125;&#125;\n\n懒汉式，线程安全(登记式/静态内部类)\n这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\npublic class SingletonPattern &#123;    //通过内部类实例化SingletonPattern    private static class SinglethonHolder&#123;        private static final SingletonPattern singletonPattern = new SingletonPattern();    &#125;    private SingletonPattern()&#123;        System.out.println(&quot;SingletonPattern被实例化了...&quot;);    &#125;    public static final SingletonPattern getInstance()&#123;        return SinglethonHolder.singletonPattern;    &#125;&#125;\n\n懒汉式，线程安全(枚举)\npublic enum SingletonPattern &#123;    INSTANCE;    public void doInstance()&#123;        System.out.println(&quot;SingletonPattern被实例化了......&quot;);    &#125;&#125;\n\n"},{"title":"markdown学习笔记","url":"/2021/04/24/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"markdown学习笔记\n标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车\n\n\n\n字体*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___\n\n分隔线**** * ******- - -----------\n\n删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可\n\n下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现:&lt;u&gt;下划线&lt;/u&gt;\n\n脚注^脚注创建脚注格式类似这样 [^脚注]。[^脚注]: 这是脚注\n\n列表(Markdown 支持有序列表和无序列表。)无序列表使用星号()、加号(+*)或是减号(-**)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项\n\n有序列表使用数字并加上 . 号来表示，如：1. 第一项2. 第二项3. 第三项\n\n列表嵌套1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素\n\n区块\nMarkdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：\n另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：\n\n&gt; 区块引用&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套\n\n区块中使用列表&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项\n\n列表中使用区块\n如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。\n\n* 第一项    &gt; 内容* 第二项\n\n代码\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（**`**），例如：\nprintf()函数\n`printf()` 函数\n\n代码区块\n代码区块使用 4 个空格或者一个制表符（Tab 键）\n​    function f(){\n​      var x = “var a = 1; var b = 2; alert(a+b)”\n​      eval(x)\n​    }\n​    f()\n你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）如:\n​```javascript    function f()&#123;        var x = &quot;var a = 1; var b = 2; alert(a+b)&quot;        \teval(x)        &#125;    f()​```\n\nfunction f()&#123;    var x = &quot;var a = 1; var b = 2; alert(a+b)&quot;    eval(x)&#125;f()\n\n链接[链接名称](链接地址)或者&lt;链接地址&gt;\n\n\n 例如：\n 这是一个链接 我的博客\n高级链接\n 我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n 这个链接用 1 作为网址变量 [Baidu][1]这个链接用 da 作为网址变量 [da][da]然后在文档的结尾为变量赋值（网址）  [1]: http://www.baidu.com/  [da]: http://da9527.gitee.io/\n\n这个链接用 1 作为网址变量 Baidu这个链接用 da 作为网址变量 da然后在文档的结尾为变量赋值（网址）\n\n\n图片![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)\n\n\n 开头一个感叹号 !接着一个方括号，里面放上图片的替代文字接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 &#x27;title&#x27; 属性的文字。\n\n表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |\n\n\n\n\n表头\n表头\n\n\n\n单元格\n单元格\n\n\n单元格\n单元格\n\n\n我们可以设置表格的对齐方式：-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。\n\n| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |\n\n\n\n\n左对齐\n右对齐\n居中对齐\n\n\n\n单元格\n单元格\n单元格\n\n\n单元格\n单元格\n单元格\n\n\n高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：    使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑\n\n使用 Ctrl+Alt+Del 重启电脑\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：**文本加粗** \\*\\* 正常显示星号 \\*\\*\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号\n\n公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 =  \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$\n\n\n$$\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\frac{\\partial X}{\\partial u} &amp;  \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\frac{\\partial X}{\\partial v} &amp;  \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\end{vmatrix}${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}$$\n更多例子可以去菜鸟教程学习"},{"title":"jdbc连接数据库","url":"/2021/05/14/jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"JDBC连接数据库Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。\nJDBC的简单使用\n先导入mysql的驱动(这里用的是Mysql8.0.22)\n\n &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;       &lt;dependency&gt;           &lt;groupId&gt;mysql&lt;/groupId&gt;           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;           &lt;version&gt;8.0.22&lt;/version&gt;       &lt;/dependency&gt;\n\n\n代码实现\n\n\n 加载驱动\n //加载MySql8.0驱动Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);//加载MySql5.0驱动Class.forName(&quot;com.mysql.jdbc.Driver&quot;)\n连接的url配置\n   //mysql8.0(8.0要配置时区不然连不上)   String url = &quot;jdbc:mysql://localhost:3306/要连接的数据库名字?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true&quot;;   //mysql5.0String url = &quot;jdbc:mysql:/localhost:3306/要连接的数据库名字&quot;;\n\n\n 代码\npackage com.demo.jdbc;import java.sql.*;/** * @Description: TODO(JDBC的简单使用) * @Author da * @Date 2021/5/14 上午 7:45 */public class JdbcTest &#123;    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;        //连接的url        String url = &quot;jdbc:mysql://localhost:3306/demo?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;rewriteBatchedStatements=true&quot;;        String admin = &quot;root&quot;;//用户名        String pwd = &quot;123456&quot;;//密码\t\t//加载驱动        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);        // 获得数据库连接        Connection conn = DriverManager.getConnection(url, admin, pwd);        //操作数据库，实现增删改查        Statement stmt = conn.createStatement();        //接收返回的结果集        ResultSet rs = stmt.executeQuery(&quot;select * from t_user&quot;);//        遍历查询结果集        while (rs.next()) &#123;            System.out.println(&quot;username: &quot; + rs.getString(&quot;username&quot;)                    + &quot;\\npassword: &quot; + rs.getString(&quot;password&quot;)                    + &quot;\\nemail: &quot; + rs.getString(&quot;email&quot;));        &#125;\t\t//关闭连接        rs.close();        stmt.close();        conn.close();    &#125;&#125;\n\n\n\n"},{"title":"servler学习笔记","url":"/2021/05/01/servler%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"Servlet 简介Servlet 是什么？Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\n1、Hello Servlet新建javaWeb工程(如图所示)视频教程1、新建java工程\n\n下一步\n\n起个名字\n\n改成web工程\n\n添加tomcat目录下的lib依赖\n\n\n\n\n\n\n\n\n\n有tomcat的依赖就行\n在web工程的src下新建包，在包里新建一个HelloServlet类:\n\n\n/** * 第一个servlet程序HelloServlet */@WebServlet(&quot;/hello&quot;)public class HelloServlet extends HttpServlet &#123;    @Override    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;        resp.getWriter().write(&quot;HelloServlet&quot;);    &#125;&#125;\n\n运行环境配置：​    \n\n\n\n\n\n运行\n运行结果:\n"},{"title":"spring学习","url":"/2021/04/22/spring%E5%AD%A6%E4%B9%A0/","content":"spring学习笔记1、配置\n 创建一个maven工程\n 给maven的配置文件添加依赖(maven仓库： https://mvnrepository.com/)  \n 下面是spring5.3.6的配置依赖\n&lt;dependencies&gt;        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;            &lt;version&gt;5.3.6&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;\n\n准备到此完成，下面开始敲代码\n\n待续……\n"},{"title":"一些Python的学习笔记","url":"/2021/04/24/%E4%B8%80%E4%BA%9BPython%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"一些Python的学习笔记\n把python打包成exe文件的方法先安装pyinstallerpip install pyinstaller\n\n打包单个exe文件-F 选项可以打出一个exe文件，默认是 -D，意思是打成一个文件夹。pyinstaller -F TestDataGen.py打出的桌面程序去掉命令行黑框-w 选项可以打桌面程序，去掉命令行黑框pyinstaller -F -w TestDataGen.py修改程序默认图标-i 可以设置图标路径，将图标放在根目录：pyinstaller -F -w -i gen.ico TestDataGen.py\n\n爬虫学习\n安装一些模块安装requests模块pip install requests网页解析模块lxmlpip install lxml\n\n\n一些爬虫案例#爬取美女校花网import requestsimport osfrom lxml import etree#UA伪装headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36&#x27;&#125;url = &#x27;http://pic.netbian.com/4kmeinv/&#x27;# 解决中文乱码问题response = requests.get(url=url,headers=headers)# response.encoding = &#x27;utf-8&#x27; #第一种方式，失败page_text = response.texttree = etree.HTML(page_text)li_list = tree.xpath(&#x27;//div[@class=&quot;slist&quot;]/ul/li&#x27;)# 创建文件夹# 如果没有aa文件夹就创建if not os.path.exists(&#x27;./aa&#x27;):    os.mkdir(&#x27;./aa&#x27;)for li in li_list:    img_src = &#x27;http://pic.netbian.com&#x27; + li.xpath(&#x27;./a/img/@src&#x27;)[0]    img_name =  li.xpath(&#x27;./a/img/@alt&#x27;)[0] + &#x27;.jpg&#x27;    # 第二种方法，通用方法    img_name = img_name.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;)    # print(img_name,img_src)    # 获取图片，持久化存储    img_data = requests.get(url=img_src,headers=headers).content    img_path = &#x27;aa/&#x27; + img_name    with open(img_path,&#x27;wb&#x27;) as fp:        fp.write(img_data)        print(img_name + &#x27;保存成功&#x27;)print(&#x27;全部保存完成&#x27;)\n\n浏览器调试案例先下载浏览器驱动,这里是Chrome驱动(ChromeDriver Mirror (taobao.org))，安装seleniumpip install selenime\n\n下面是chrome跟火狐的案例from selenium import webdriverfrom time import sleep#chromebro = webdriver.Chrome(executable_path=&#x27;./chromedriver.exe&#x27;)#火狐# bro = webdriver.Firefox(executable_path=&#x27;./geckodriver.exe&#x27;)bro.get(&#x27;https://www.dogedoge.com/&#x27;)# 获取输入框位置，并且输入信息sosou = bro.find_element_by_id(&quot;search_form_input_homepage&quot;)sosou.send_keys(&#x27;美女&#x27;)sleep(2)# 获取搜索按钮位置，点击搜索sbtu = bro.find_element_by_id(&quot;search_button_homepage&quot;)sbtu.click()sleep(2)# 浏览信息,向下翻一个屏幕的距离bro.execute_script(&#x27;window.scrollTo(0,document.body.scrollHeight)&#x27;)sleep(2)# 回退bro.back()sleep(2)# 前进bro.forward()sleep(2)# 打开百度bro.get(&#x27;http://www.baidu.com/&#x27;)# 加入JS操作bro.execute_script(&quot;alert(&#x27;已经是最后一步了&#x27;)&quot;)sleep(5)bro.quit()\n\n无头浏览器调试from selenium import webdriver# 实现无可视化from selenium.webdriver.chrome.options import Options# 规避检测from selenium.webdriver import ChromeOptions# 实现无可视化chrome_options = Options()chrome_options.add_argument(&#x27;--headless&#x27;)chrome_options.add_argument(&#x27;--disable-gpu&#x27;)# 规避检测option = ChromeOptions()option.add_experimental_option(&#x27;excludeSwitches&#x27;,[&#x27;enable-automation&#x27;])# 加入chrome_options=chrome_options 和 options=optionbro = webdriver.Chrome(executable_path=&#x27;./chromedriver.exe&#x27;,chrome_options=chrome_options,options=option)bro.get(&#x27;https://www.baidu.com/&#x27;)# 持久化存储with open(&#x27;aa.html&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as fp:    fp.write(bro.page_source)bro.quit()\n\n获取百度翻译内容import requestsimport json# 指定urlpost_url = &#x27;https://fanyi.baidu.com/sug&#x27;# UA伪装headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36&#x27;&#125;# 获取输入值sr = input(&#x27;输入查询值:&#x27;)# post请求参数处理（与get请求一致）data = &#123;    &#x27;kw&#x27; : sr&#125; # 请求发送response = requests.post(url=post_url,data=data,headers=headers)# 获取响应数据:json()方法返回的是obj（确认返回对象是json才能用jsob()）dic_obj = response.json()# 持久化储存file_name = sr + &#x27;.json&#x27;with open(file_name,&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;) as cs:    json.dump(dic_obj,fp=cs,ensure_ascii=False)print(&#x27;完成&#x27;)\n\n用python画图画图模块下载turtle(https://files.pythonhosted.org/packages/ff/f0/21a42e9e424d24bdd0e509d5ed3c7dfb8f47d962d9c044dba903b0b4a26f/turtle-0.0.2.tar.gz)打开setup.py文件，第40行修改为 :except (ValueError ve):\n\n#本地安装(直接pip安装不了的,需要像这样修改过后,本地安装才能装上)pip install -e D:\\\\turtle-0.0.2-e后面接上我们修改过setup.py文件的目录\n\n画图案例：#旋转风车from turtle import *bgcolor(&#x27;black&#x27;)color = [&#x27;red&#x27;,&#x27;yellow&#x27;,&#x27;pink&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;,&#x27;purple&#x27;]# 六边形# for i in range(100):#     pencolor(color[i%6])#     forward(i)#     left(61)# 三角形for i in range(100):    pencolor(color[i%3])    forward(i)    left(121)# 正方形for i in range(100):    pencolor(color[i%6])    forward(i)    left(91)hideturtle()exitonclick()\n\n图片转字符画#先安装：PIL库pip install Pillow\n\nfrom PIL import Image#定义字符串codeLib = &quot;$@B%8&amp;WM#*oahkbdpqw mZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_ +~&lt;&gt;i!lI;:,\\&quot;^`&#x27;. &quot;count = len(codeLib)img = Image.open(r&quot;D:\\汇总文件\\Py\\自学笔记\\爬虫\\画图\\1.jpg&quot;)def transfrom(img_file):    img_file = img_file.convert(&#x27;L&#x27;)#把彩色图转成黑白图    # img_file.show() #这里可以查看图片    codePic = &#x27;&#x27;    for h in range(0,img_file.size[1]):#图片的高        for w in range(0,img_file.size[0]):#图片的宽            gray = img_file.getpixel((w,h))#图片的灰度            codePic = codePic + codeLib[int(((count - 1)*gray)/256)]         codePic = codePic + &#x27;\\n&#x27;#打完一行换行    return codePictext = transfrom(img)with open(&#x27;aa.txt&#x27;,&#x27;w&#x27;) as fp:    fp.write(text)print(&#x27;over&#x27;)\n\n键盘操作#安装pynput模块pip install pynput\n\n#跟爬虫结合实现连发发送名人名言案例import pynput as pimport timeimport requestsfrom lxml import etreeurl = &#x27;http://www.yuluju.com/lizhimingyan/11246.html&#x27;headers = &#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36&#x27;&#125;time.sleep(5)page = requests.get(url=url,headers=headers)page.encoding=&#x27;gb2312&#x27;page_text = page.texttree = etree.HTML(page_text)span_list = tree.xpath(&#x27;//*[@id=&quot;p_left&quot;]/div[1]/div[4]//span/text()&#x27;)for span in span_list[2:]:    text = span    # print(text)    keyboard = p.keyboard    key = keyboard.Key    ctrl = keyboard.Controller()    ctrl.type(text)    time.sleep(1)    ctrl.press(key.enter)    ctrl.release(key.enter)\n\n\n\n\n\n"},{"title":"自定义Promise","url":"/2021/04/24/%E8%87%AA%E5%AE%9A%E4%B9%89Promise/","content":"自定义Promise\nclass Promise &#123;  // 构造方法  constructor(executor) &#123;    // 添加属性    this.PromiseState = &quot;pending&quot;; //Promise状态    this.PromiseResult = null; //函数执行的结果    // 声明属性    this.callbacks = [];    // 保存实例对象的this值    const self = this;    // resolve函数    function resolve(data) &#123;      // 只能修改一次状态,如果状态还是pending就修改      if (self.PromiseState !== &quot;pending&quot;) return; //不是pending状态就不执行下面的      // 执行此方法,改变Promise的状态为(fulfilled)      self.PromiseState = &quot;fulfilled&quot;;      // 设置对象的结果值(PromiseResult)      self.PromiseResult = data;      // 调用成功的回调函数(异步操作)      setTimeout(() =&gt; &#123;        self.callbacks.forEach((item) =&gt; &#123;          item.onResolved(data);        &#125;);      &#125;);    &#125;    // reject函数    function reject(data) &#123;      // 只能修改一次状态,如果状态还是pending就修改      if (self.PromiseState !== &quot;pending&quot;) return; //不是pending状态就不执行下面的      // 执行此方法,改变Promise的状态为(rejected)      self.PromiseState = &quot;rejected&quot;;      // 设置对象的结果值(PromiseResult)      self.PromiseResult = data;      // 调用失败的回调函数(异步操作)      setTimeout(() =&gt; &#123;        self.callbacks.forEach((item) =&gt; &#123;          item.onRejected(data);        &#125;);      &#125;);    &#125;    // 同步调用[执行器函数]    try &#123;      executor(resolve, reject);    &#125; catch (error) &#123;      // 修改promise的状态为失败      reject(error);    &#125;  &#125;  // then方法封装  then(onResolved, onRejected) &#123;    const self = this;    //   判断回调函数(异常穿透)    if (typeof onRejected !== &quot;function&quot;) &#123;      onRejected = (reason) =&gt; &#123;        throw reason;      &#125;;    &#125;    // 如果第一个值不传给他一个默认参数,让后面可以继续    if (typeof onResolved !== &quot;function&quot;) &#123;      onResolved = (value) =&gt; value;    &#125;    return new Promise((resolve, reject) =&gt; &#123;      //   封装函数      function callback(type) &#123;        try &#123;          // 获取回调函数的执行结果          let result = type(self.PromiseResult);          // 判断          if (result instanceof Promise) &#123;            // 如果是Promise类型的对象            result.then(              (v) =&gt; &#123;                resolve(v);              &#125;,              (r) =&gt; &#123;                reject(r);              &#125;            );          &#125; else &#123;            // 结果对象状态为成功            resolve(result);          &#125;        &#125; catch (error) &#123;          reject(error);        &#125;      &#125;      // 调用回调函数      if (this.PromiseState === &quot;fulfilled&quot;) &#123;        setTimeout(() =&gt; &#123;          //异步执行          callback(onResolved);        &#125;);      &#125;      if (this.PromiseState === &quot;rejected&quot;) &#123;        setTimeout(() =&gt; &#123;          //异步执行          callback(onRejected);        &#125;);      &#125;      // 判断 pending 的状态      if (this.PromiseState === &quot;pending&quot;) &#123;        // 保存回调函数        this.callbacks.push(&#123;          onResolved: function () &#123;            callback(onResolved);          &#125;,          onRejected: function () &#123;            callback(onRejected);          &#125;,        &#125;);      &#125;    &#125;);  &#125;  // catch方法封装  catch(onRejected) &#123;    return this.then(undefined, onRejected);  &#125;  // resolve方法封装  static resolve(value) &#123;    // 返回Promise对象    return new Promise((resolve, reject) =&gt; &#123;      if (value instanceof Promise) &#123;        value.then(          (v) =&gt; &#123;            resolve(v);          &#125;,          (r) =&gt; &#123;            reject(r);          &#125;        );      &#125; else &#123;        resolve(value);      &#125;    &#125;);  &#125;  //reject方法封装  static reject(reason) &#123;    return new Promise((resolve, reject) =&gt; &#123;      reject(reason);    &#125;);  &#125;  // 封装all方法(promise对象的状态都为成功时才把状态改成成功)  static all(promise) &#123;    // 返回结果为Promise对象    return new Promise((resolve, reject) =&gt; &#123;      // 声明变量      let count = 0;      let arr = [];      // 遍历数组      for (let i = 0; i &lt; promise.length; i++) &#123;        promise[i].then(          (v) =&gt; &#123;            // 对象状态是成功            // 要每个Promise的对象都成功            count++;            // 将当前的promise对象存入数组中            arr[i] = v;            // 都为成功状态才调resolve            if (count === promise.length) &#123;              resolve(arr);            &#125;          &#125;,          (r) =&gt; &#123;            reject(r);          &#125;        );      &#125;    &#125;);  &#125;  // 封装 race 方法(谁先调promise状态就是谁的状态)  static race(promise) &#123;    return new Promise((resolve, reject) =&gt; &#123;      // 遍历数组      for (let i = 0; i &lt; promise.length; i++) &#123;        promise[i].then(          (v) =&gt; &#123;            // 修改返回结果为成功            resolve(v);          &#125;,          (r) =&gt; &#123;            // 修改返回结果为失败            reject(r);          &#125;        );      &#125;    &#125;);  &#125;&#125;\n\n"},{"title":"一些javascript学习的笔记","url":"/2021/04/20/%E4%B8%80%E4%BA%9Bjavascript%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AC%94%E8%AE%B0/","content":"js生成随机颜色function randomColor()&#123;    let chars = &#x27;0123456789abcdef&#x27;    let colorLength = 6    let color = &#x27;&#x27;    for (let i = 0; i &lt; colorLength; i++) &#123;    let randomCode = Math.floor(Math.random() * chars.length)    color += chars.substring(randomCode,randomCode+1)    &#125;    return &quot;#&quot; + color    &#125;\n\n\n体现js是动态语言的小例子动态执行：javascript提供eval()函数，用于动态解释一段文本，并在当前上下文环境中执行。&lt;script&gt;    function f()&#123;    var x = &quot;var a = 1; var b = 2; alert(a+b)&quot;    eval(x)    &#125;    f()&lt;/script&gt;\n\n\nfetch简单使用function rQ(url) &#123;    return new Promise((resolve, reject) =&gt; &#123;      fetch(url)        .then(function (response) &#123;          return response.json();        &#125;)        .then(function (myJson) &#123;          resolve(myJson)        &#125;)        .catch((err) =&gt; reject(err));    &#125;);  &#125;  //post请求  postData(&#x27;http://example.com/answer&#x27;, &#123;answer: 42&#125;)  .then(data =&gt; console.log(data)) // JSON from `response.json()` call  .catch(error =&gt; console.error(error))function postData(url, data) &#123;  // Default options are marked with *  return fetch(url, &#123;    body: JSON.stringify(data), // must match &#x27;Content-Type&#x27; header    cache: &#x27;no-cache&#x27;, // *default, no-cache, reload, force-cache, only-if-cached    credentials: &#x27;same-origin&#x27;, // include, same-origin, *omit    headers: &#123;      &#x27;user-agent&#x27;: &#x27;Mozilla/4.0 MDN Example&#x27;,      &#x27;content-type&#x27;: &#x27;application/json&#x27;    &#125;,    method: &#x27;POST&#x27;, // *GET, POST, PUT, DELETE, etc.    mode: &#x27;cors&#x27;, // no-cors, cors, *same-origin    redirect: &#x27;follow&#x27;, // manual, *follow, error    referrer: &#x27;no-referrer&#x27;, // *client, no-referrer  &#125;)  .then(response =&gt; response.json()) // parses response to JSON&#125;\n\n\n三元运算let a = 300let b = 200let max = a &gt; b ? a : bconsole.log(max);\n\n\n批量添加标签 let div = document.querySelector(&#x27;div&#x27;)        for(let i = 0; i &lt; 7; i++)&#123;            const span = document.createElement(&#x27;span&#x27;)            div.appendChild(span)        &#125;\n\n\n鼠标移入移出事件var tar = document.querySelectorAll(&#x27;button&#x27;);    for(var i = 0; i &lt; tar.length; i++)&#123;        // 鼠标移入事件        tar[i].onmouseover = function()&#123;            this.style.backgroundColor = &#x27;red&#x27;;        &#125;;        // 鼠标移出事件        tar[i].onmouseout = function()&#123;            this.style.backgroundColor = &#x27;&#x27;;        &#125;;    &#125;\n\n\nasync和await的简单使用&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;axios+async+await&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;button&gt;点我一下&lt;/button&gt;    &lt;script&gt;        document.querySelector(&#x27;button&#x27;).onclick = async() =&gt; &#123;            let data = await axios.get(&#x27;https://api.apiopen.top/getJoke&#x27;)            let arr = data.data.result            arr.forEach(item =&gt; &#123;               console.log(item.text);             &#125;);        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\nasync+fetch简单使用&lt;script&gt;      let btn = document.createElement(&quot;button&quot;);      btn.innerHTML = &quot;点我一下&quot;;      document.body.appendChild(btn);      document.querySelector(&quot;button&quot;).onclick = async () =&gt; &#123;        let res = await fetch(&quot;https://api.apiopen.top/getJoke&quot;);        let data = await res.json();        data.result.forEach((item) =&gt; &#123;          console.log(item.text);        &#125;);      &#125;;&lt;/script&gt;\n\n"},{"title":"我用node遇到的一些问题","url":"/2021/04/24/%E6%88%91%E7%94%A8node%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/","content":"node的一些问题\n读取中文乱码问题(解决一部分的方法,无法解决所有乱码问题)安装下面的包npm install -g iconv-litenpm install -g nodemailernpm install -g node-schedule\n\n先统一用二进制编码方式读取，然后再用GBK解码var iconv = require(&#x27;iconv-lite&#x27;);var fs = require(&#x27;fs&#x27;);var fileStr = fs.readFileSync(&#x27;文件路径加文件名&#x27;, &#123;encoding:&#x27;binary&#x27;&#125;);var buf = new Buffer(fileStr, &#x27;binary&#x27;);var str = iconv.decode(buf, &#x27;GBK&#x27;);console.log(str);\n\n用node简单爬取网页先安装安装requests包npm i requests --save-dev\n\nlet requests = require(&#x27;requests&#x27;) // 请求包let fs =require(&#x27;fs&#x27;) // 读写文件let path = require(&#x27;path&#x27;) // 定义文件路径requests(&#x27;https://www.baidu.com&#x27;) // 请求路径.on(&#x27;data&#x27;, function (chunk) &#123;  fs.writeFile(path.resolve(__dirname,&#x27;index.html&#x27;),chunk,()=&gt;&#123; //将请求得到的资源文件写入本地项目文件夹下的index.html（名字可改）中      console.log(&quot;保存成功&quot;) // 数据爬取成功，输出“保存成功”  &#125;)&#125;).on(&#x27;end&#x27;, function (err) &#123;  if (err) return console.log(&#x27;connection closed due to errors&#x27;, err);  console.log(&#x27;end&#x27;);&#125;);\n\n使用qs模块转换字符串const qs = require(&#x27;querystring&#x27;)let strObj = &#123;id:1,name:&#x27;小明&#x27;&#125;//用qs转成 id=1&amp;name=小明console.log(qs.stringify(strObj));console.log(&#x27;******************&#x27;);let str = &#x27;?id=1&amp;name=小明&#x27;//用qs转成 &#123;?id:1,name:&#x27;小明&#x27;&#125;console.log(qs.parse(str));console.log(&#x27;*****************&#x27;);console.log(qs.parse(str.slice(1)));//用qs转成 &#123;id:1,name:&#x27;小明&#x27;&#125;\n\n\n\n\n\n"},{"title":"正则表达式学习","url":"/2021/04/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/","content":"正则表达式\n限定符：a*\ta出现0次或者多次a+ a出现1次或者多次a?\ta出现0次或者1次a&#123;6&#125;  a出现6次a&#123;2,&#125;  a出现2次以上\n\n或运算符：（a|b）\t匹配a或者b(ab)|(cd)\t匹配ab或者cd\n\n字符类：[abc]\t匹配a或者b或者c[a-c]\t匹配a或者b或者c[a-fA-F0-9]\t匹配小写+大写英文字符以及数字[^0-9]\t匹配非数字字符\n\n元字符：\\d\t\t匹配数字字符\\D\t\t匹配非数字字符\\w\t\t匹配单词字符(英文、数字、下划线)\\W\t\t匹配非单词字符\\s\t\t匹配空白字符\\S\t\t匹配非空白字符.\t\t匹配任意字符(换行符除外)\\bword\\b \t\t\\b标注字符的边界(全字匹配)^\t\t匹配行首$\t\t匹配行尾\n\n贪婪/懒惰匹配：&lt;.+&gt;\t默认贪婪匹配“任意字符”&lt;.+?&gt;\t懒惰匹配“任意字符”\n\n"},{"title":"搭建属于你自己的个人博客","url":"/2021/04/19/%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"hexo-cli基本使用关于hexo的详细文档什么的去hexo官网了解(https://hexo.io/zh-cn/)\n1、安装\n先安装 node.js 、Git 最好也安装上，后面会用到 \n最好装个cnpm，下载hexo-cli会快一些\nnpm i -g cnpm --registry=http://registry.npm.taobao.org\n\n安装hexo-cli\ncnmp i hexo-cli -g\n\n测试hexo-cli 是否安装成功\n&gt;hexo -v\n\n2、开始搭建个人博客\n先创建一个放博客工程的文件夹(不创建其实也行)\nmkdir boke\n\n进入boke 文件夹\ncd boke\n\n初始化博客\nhexo init\n\n启动本地博客服务\nhexo s\n\n本地博客访问网址：\nhttp://localhost:4000/\n\n到此个人博客已经差不多算搭建成功了(不过只能本地访问)\n创建一篇的博客\nhexo n &quot;我创建的一篇新博客&quot;\n\n\n\n3、部署到gitee(https://gitee.com/)\n  先注册账号\n\n 然后创建仓库\n 仓库名称最好和自己的账号一致，后面搭建成功后网址会和我的差不多(https://da9527.gitee.io/)\n 如果仓库名不和自己账号名字一致,可能会丢失样式，找不到资源等等问题\n 勾选 使用Readme文件初始化仓库 然后创建仓库\n\n\n\n  创建好仓库后在服务里选 Gitee Pages 勾选强制使用https，然后确定，等待部署，把部署出来的网址\n 复制一下，像我的就是(https://da9527.gitee.io) 以后通过这个网址就能访问你自己的博客\n\n\n进入boke 文件夹\n用文件编辑器打开 _config.yml (个人推荐用vscode打开，当然记事本也是没问题的,vscode有代码高亮看起来舒服很多) \n# Sitetitle: Da的个人博客 //博客标题subtitle: &#x27;&#x27;description: &#x27;&#x27;keywords:author: Da  //你自己language: zh-CN //网址默认语言,最好改成我这样,如果是默认英文谷歌浏览器就会弹出要不要翻译的弹窗timezone: &#x27;&#x27; # URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://da9527.gitee.io //这里改成你刚刚复制的网址permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n\n安装git部署插件cnpm install --save hexo-deployer-git\n\n# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: keep //这里是主题(主题就去hexo官网自行研究了)# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  //如果没有初始化git配置先初始化一下(具体操作看我另一篇关于Git的文章)  repo: https://gitee.com/da9527/da9527.git //gitee仓库地址  branch: master //默认master分支就行\n\n到此本地就基本配置完成了，接下来就是推送到Gitee\n\n 先清理一下\nhexo cl\n\n生成一下\nhexo g\n\n本地测试一下\nhexo s\n\n如果没问题就停掉本地服务(ctrl+c)\n然后推送到Gitee\nhexo d\n\n会跳出账号密码让你输入，输入你自己的账号密码就行\n\n\n4、最后\n 去你gitee仓库看是否推送上去了，然后去 服务  &gt;&gt; Gitee Pages &gt;&gt; 更新 等更新完成\n点击你的网址，没错不出意外你就已经访问成功了。(关于配置主题什么的，我建议去官网 https://hexo.io/zh-cn/ ，里面有主题作者自己写好的教程)\n\n"}]